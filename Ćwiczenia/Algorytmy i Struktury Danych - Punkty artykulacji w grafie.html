
<!-- saved from url=(0050)https://eduinf.waw.pl/inf/alg/001_search/0130b.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">

<meta http-equiv="Content-Language" content="pl">
<title>Algorytmy i Struktury Danych - Punkty artykulacji w grafie</title>
<meta name="description" content="Artyku³ opisuje ró¿ne algorytmy wyszukuj±ce informacje w zbiorach danych takich jak przedzia³y liczbowe, tablice, macierze, wektory, listy, drzewa, grafy, teksty itp.">
<meta name="keywords" content="wyszukiwanie, algorytm, programowanie, c++, pascal, basic, informatyka, liceum, matura, olimpiada, matematyka">
<link rel="stylesheet" type="text/css" href="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/001.css">
<script src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(6).txt"></script><script src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/ca-pub-2048408300128807.js.pobrane"></script><script type="text/javascript" language="javascript" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/h.js.pobrane"></script>
<!--<base target="_top">--><base href="." target="_top">
        <script async="" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(7).txt"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2048408300128807",
    enable_page_level_ads: true
  });
</script>
<link rel="preload" href="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(8).txt" as="script"><script type="text/javascript" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(8).txt"></script><link rel="preload" href="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(9).txt" as="script"><script type="text/javascript" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(9).txt"></script></head>

<body><table border="0" width="100%" cellpadding="0" style="border-collapse: collapse">
  <tbody><tr>
    <td width="164" style="text-align: left" valign="top" class="menu_l"><a href="http://www.i-lo.tarnow.pl/"><img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/i-lo_logo.gif" width="164" height="170" style="margin-top: 12px" alt="Do strony g³ównej I LO w Tarnowie"></a></td>
    <td style="text-align: center" valign="top" class="menu_m" nowrap="">
    <a class="exit" href="https://eduinf.waw.pl/inf/index.php"><span>Wyj¶cie </span></a><a class="cont" href="https://eduinf.waw.pl/inf/alg/001_search/index.php"><span>Spis tre¶ci </span></a><a class="prev" href="https://eduinf.waw.pl/inf/alg/001_search/0130a.php"><span>Poprzedni </span></a><a class="next" href="https://eduinf.waw.pl/inf/alg/001_search/0131.php"><span>Nastêpny </span></a>
<p><img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_title.jpg" width="511" height="195" alt="tytu³"></p>
    <span class="small">Prezentowane materia³y s± przeznaczone dla uczniów szkó³ ponadgimnazjalnych</span>.<br>
    Autor artyku³u: mgr Jerzy Wa³aszek,&nbsp; wersja 2.0</td>
    <td style="padding:8px; text-align: center" valign="top" class="menu_r" nowrap="" width="200">
    <p class="small" style="line-height: 100%; margin-bottom: 0">&nbsp;&#169;2014 mgr Jerzy Wa³aszek<br>
    I LO w Tarnowie</p>
    <p><img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_logo.gif" width="134" height="102" alt="logo"></p>
    </td>
  </tr>
  <tr>
    <td style="text-align: center" colspan="3" height="10">
<script async="" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/f(7).txt"></script>
<!-- normal_page -->
<ins class="adsbygoogle" style="display: block; height: 0px;" data-ad-client="ca-pub-2048408300128807" data-ad-slot="9328341371" data-ad-format="auto" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 1200px; background-color: transparent;"><ins id="aswift_1_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 1200px; background-color: transparent; overflow: hidden; transition: opacity 1s cubic-bezier(0.4, 0, 1, 1) 0s, width 0.2s cubic-bezier(0.4, 0, 1, 1) 0.3s, height 0.5s cubic-bezier(0.4, 0, 1, 1) 0s; opacity: 0;"><iframe width="1200" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:1200px;height:90px;" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/saved_resource(2).html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</td>
  </tr>
  </tbody></table>
<h1 class="sb1">Znajdowanie punktów artykulacji w grafie</h1>
<hr color="#336699" size="1">
<table border="0" cellspacing="0" cellpadding="4" style="border-collapse: collapse" class="sb1" id="table248">
	<tbody><tr>
		<td bgcolor="#CCCCCC"><b>Tematy pokrewne</b></td>
<td bgcolor="#CCCCCC">&nbsp;</td>
<td bgcolor="#CCCCCC"><b>Podrozdzia³y</b></td>
</tr>
	<tr>
		<td valign="top"><b><a href="https://eduinf.waw.pl/inf/alg/001_search/0122.php">Grafy</a></b><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0123.php">Podstawowe pojêcia dotycz±ce grafów</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0124.php">Reprezentacja grafów w komputerze</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0125.php">Przechodzenie grafów w g³±b &#8211; DFS</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126.php">Przechodzenie grafów wszerz &#8211; BFS</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126a.php">Transpozycja grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126b.php">Kwadrat grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126c.php">Graf krawêdziowy</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126d.php">Stopieñ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0127.php">Znajdowanie ¶cie¿ki w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0128.php">Znajdowanie drogi w labiryncie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0128a.php">Spójno¶æ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129.php">Znajdowanie spójnych sk³adowych w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129a.php">Znajdowanie silnie spójnych 
					sk³adowych w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130.php">Drzewa rozpinaj±ce grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130a.php">Znajdowanie mostów w grafie</a><br>
		<font color="#FF0000"><b>Znajdowanie punktów artykulacji w grafie</b></font><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0131.php">Grafy dwudzielne</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0131a.php">Kojarzenie ma³¿eñstw</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0132.php">Cykliczno¶æ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0133.php">Znajdowanie cykli w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0134.php">Istnienie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0135.php">Znajdowanie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0136.php">Znajdowanie cyklu lub ¶cie¿ki 
					Hamiltona</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0137.php">Sortowanie topologiczne grafu 
					skierowanego</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138.php">Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Dijkstry</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138a.php">Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Bellmana-Forda</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138b.php">Najkrótsze ¶cie¿ki pomiêdzy 
					wszystkimi parami wierzcho³ków w grafie wa¿onym</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0139.php">Problem chiñskiego listonosza</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0140.php">Problem komiwoja¿era</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0141.php">Minimalne drzewo rozpinaj±ce</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0142.php">Kolorowanie grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0143.php">Znajdowanie klik w grafie</a></td>
		<td valign="top">&nbsp;</td>
		<td valign="top"><a href="https://eduinf.waw.pl/inf/alg/001_search/0130b.php#P1">Rozwi±zanie nr 1</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130b.php#P2">Rozwi±zanie nr 2</a></td>
	</tr>
</tbody></table>
<div class="bl2">
  <p class="mlink">&nbsp;</p></div>
<div class="bl1">
<h3>Problem</h3>
<p class="bl2">Dla danego grafu nieskierowanego wyznaczyæ wszystkie punkty 
artykulacji.</p>
<div class="sb1">
	<p style="text-align: center"><br>
<br>
	<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_01.gif" width="402" height="148"></p>
	<p style="text-align: center">&nbsp;</p>
	<p><b>Punktem artykulacji</b> <span class="rem" lang="en">(ang. articulation 
	point lub cut vertex)</span> jest wierzcho³ek, którego usuniêcie z grafu 
	spowoduje zwiêkszenie liczby spójnych sk³adowych. Na powy¿szym rysunku 
	punktem artykulacji jest wierzcho³ek nr 0.</p>
	<p>&nbsp;</p>
</div>
<h3><a name="P1"></a>Rozwi±zanie nr 1
</h3>
<div class="sb1">
	<p>&nbsp;</p>
	<p>Naiwny sposób rozwi±zania tego problemu jest nastêpuj±cy:</p>
	<p>&nbsp;</p><div class="google-auto-placed" style="text-align: center; width: 100%; height: auto; clear: both;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-2048408300128807" data-adsbygoogle-status="done" style="display: block; margin: 10px auto 6px; background-color: transparent; height: 90px;"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><iframe width="1200" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:1200px;height:90px;" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/saved_resource(3).html"></iframe></ins></ins></ins></div><div class="bl1">Obliczamy wstêpnie liczbê spójnych sk³adowych 
		w grafie <span class="rem">(mo¿emy tutaj wykorzystaæ algorytm opisany w
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129.php#A">rozdziale o spójnych sk³adowych</a>)</span> i 
		zapamiêtujemy j±. Nastêpnie przechodzimy przez kolejne wierzcho³ki 
		grafu. Ka¿dy bie¿±cy wierzcho³ek usuwamy wraz ze wszystkimi incydentnymi 
		z nim krawêdziami i ponownie obliczamy liczbê spójnych sk³adowych. Je¶li 
		jest ona wiêksza od zapamiêtanej, to usuniêty wierzcho³ek jest punktem 
		artykulacji i zapamiêtujemy go na li¶cie. Wierzcho³ek wstawiamy z 
		powrotem wraz ze wszystkimi usuniêtymi poprzednio krawêdziami i 
		przechodzimy do nastêpnego wierzcho³ka. Gdy algorytm zakoñczy dzia³anie, 
		lista bêdzie zawiera³a wszystkie punkty artykulacji grafu</div>
	<p>&nbsp;</p>
<h4><a name="A1"></a>Algorytm naiwny wyszukiwania punktów artykulacji w grafie nieskierowanym</h4>
<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table252" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>n</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba wierzcho³ków w grafie, <i>n</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
<table id="table258" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista par wierzcho³ków, które tworz± krawêdzie-mosty.</td>
  </tr>
  </tbody></table>
	</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table254" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap="">ccn(<i>n</i>,<i>graf</i>)</td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>funkcja zwracaj±ca liczbê spójnych sk³adowych w grafie</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>nc</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba spójnych sk³adowych grafu,&nbsp; <i>nc</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>v</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>numery wierzcho³ka grafu,&nbsp; <i>v</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table255">
    <tbody><tr>
      <td valign="top">K01:</td>
      <td nowrap="" valign="top">Utwórz pust± listê <i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K02:</td>
      <td nowrap="" valign="top"><i>nc</i> &#8592; ccn(<i>n</i>,<i>graf</i>)</td>
      <td class="c" valign="top">; zapamiêtujemy liczbê spójnych sk³adowych</td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top"><b>Dla</b> <i>v</i> = 0,1,...,<i>n</i>-1, <b>
		wykonuj</b> K04...K06</td>
      <td class="c" valign="top">; przechodzimy przez kolejne wierzcho³ki grafu</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; Usuñ wierzcho³ek <i>v</i> z <i>
		grafu</i> wraz z jego krawêdziami</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>
		Je¶li</b> ccn(<i>v</i>,<i>graf</i>) &gt; <i>nc</i>, <b>to</b> dodaj <i>v</i> 
		do <i>L</i></td>
      <td class="c" valign="top">; je¶li v jest punktem artykulacji, to zapamiêtujemy 
		go w L</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; Odtwórz wierzcho³ek <i>v</i> w
		<i>grafie</i> wraz z jego krawêdziami</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top"><b>Zakoñcz</b></td>
      <td class="c" valign="top">; punkty artykulacji w L</td>
    </tr>
    </tbody></table>
  <p>&nbsp;</p></div>
<h4>Program</h4> <div class="sb1"><table border="0" cellpadding="8" style="border-collapse: collapse">
    <tbody><tr>
      <td class="note"><b>Wa¿ne</b>:<br>
 <p class="bl1">Zanim uruchomisz program, przeczytaj <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td></tr>
  </tbody></table>
  <p>&nbsp;</p>
</div><div class="sb1">
	Program odczytuje <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0124.php#P1">definicjê</a> grafu 
	nieskierowanego, wyszukuje w nim wszystkie punkty artykulacji i wypisuje je 
	w oknie konsoli. Poniewa¿ usuwanie i odtwarzanie wierzcho³ka grafu mo¿e byæ 
	k³opotliwe, zastosowali¶my dodatkow± tablicê logiczn± VU. Elementy tej 
	tablicy odpowiadaj± wierzcho³kom grafu. Wierzcho³ek obecny w grafie ma w tej 
	tablicy warto¶æ true. Wierzcho³ek usuniêty ma warto¶æ false.<p>&nbsp;</p>
	<p>Przyk³adowe dane:</p>
	<table border="0" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td>
				<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_02.gif" width="243" height="148"></td>
				<td><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
				<td>8 11<br>
				0 1 0 2 0 3 0 5<br>
				1 4 1 5<br>
				2 3<br>
				3 6 3 7<br>
				4 5<br>
				6 7</td>
			</tr>
		</tbody></table>
	<p>&nbsp;</p>
	<table border="1" id="table257" cellspacing="0" cellpadding="4" style="border-collapse: collapse" bordercolor="#808080">
		<tbody><tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Lazarus</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="pas"><pre><span class="c">// Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">// Data: 29.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//---------------------------------------------------------</span>

<span class="i">program</span> <span class="v">artpnts</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy punktów artykulacji</span>

<span class="i">type</span>
  <span class="v">PslistEl</span> = ^<span class="v">slistEl</span>;
  <span class="v">slistEl</span> =  <span class="i">record</span>
    <span class="v">next</span>  : <span class="v">PslistEl</span>;
    <span class="v">v</span>     : <span class="v">integer</span>;
  <span class="i">end</span>;

<span class="v">TList</span> = <span class="i">array</span> <span class="i">of</span> <span class="v">PslistEl</span>;

<span class="c">// Definicja typu obiektowego stack</span>
<span class="c">//---------------------------------</span>

<span class="v">stack</span> = <span class="i">object</span>
  <span class="v">private</span>
    <span class="v">S</span> : <span class="v">PslistEl</span>;  <span class="c">// lista przechowuj±ca stos</span>

  <span class="v">public</span>
    <span class="i">constructor</span> <span class="v">init</span>;
    <span class="i">destructor</span> <span class="v">destroy</span>;
    <span class="i">function</span>   <span class="v">empty</span> : <span class="v">boolean</span>;
    <span class="i">function</span>   <span class="v">top</span> : <span class="v">integer</span>;
    <span class="i">procedure</span>  <span class="v">push</span>(<span class="v">v</span> : <span class="v">integer</span>);
    <span class="i">procedure</span>  <span class="v">pop</span>;
<span class="i">end</span>;

<span class="c">// Konstruktor</span>
<span class="c">//------------</span>
<span class="i">constructor</span> <span class="v">stack</span>.<span class="v">init</span>;
<span class="i">begin</span>
  <span class="v">S</span> := <span class="v">nil</span>;
<span class="i">end</span>;

<span class="c">// Destruktor</span>
<span class="c">//-----------</span>

<span class="i">destructor</span> <span class="v">stack</span>.<span class="v">destroy</span>;
<span class="i">begin</span>
  <span class="i">while</span> <span class="v">S</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span> <span class="v">pop</span>;
<span class="i">end</span>;

<span class="c">// Sprawdza, czy stos jest pusty</span>
<span class="c">//------------------------------</span>
<span class="i">function</span> <span class="v">stack</span>.<span class="v">empty</span> : <span class="v">boolean</span>;
<span class="i">begin</span>
  <span class="i">if</span> <span class="v">S</span> = <span class="v">nil</span> <span class="i">then</span> <span class="v">empty</span> := <span class="v">true</span> <span class="i">else</span> <span class="v">empty</span> := <span class="v">false</span>;
<span class="i">end</span>;

<span class="c">// Zwraca liczbê ze szczytu stosu</span>
<span class="c">//----------------------------------</span>
<span class="i">function</span> <span class="v">stack</span>.<span class="v">top</span> : <span class="v">integer</span>;
<span class="i">begin</span>
  <span class="v">top</span> := <span class="v">S</span>^.<span class="v">v</span>;
<span class="i">end</span>;

<span class="c">// Umieszcza dane na stosie</span>
<span class="c">//-------------------------</span>
<span class="i">procedure</span> <span class="v">stack</span>.<span class="v">push</span>(<span class="v">v</span> : <span class="v">integer</span>);
<span class="i">var</span>
  <span class="v">e</span> : <span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="v">new</span>(<span class="v">e</span>);
  <span class="v">e</span>^.<span class="v">v</span> := <span class="v">v</span>;
  <span class="v">e</span>^.<span class="v">next</span> := <span class="v">S</span>;
  <span class="v">S</span> := <span class="v">e</span>;
<span class="i">end</span>;

<span class="c">// Usuwa dane ze stosu</span>
<span class="c">//--------------------</span>
<span class="i">procedure</span> <span class="v">stack</span>.<span class="v">pop</span>;
<span class="i">var</span>
  <span class="v">e</span> :<span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="i">if</span> <span class="v">S</span> &lt;&gt; <span class="v">NIL</span> <span class="i">then</span>
  <span class="i">begin</span>
    <span class="v">e</span> := <span class="v">S</span>;
    <span class="v">S</span> := <span class="v">S</span>^.<span class="v">next</span>;
    <span class="v">dispose</span>(<span class="v">e</span>);
  <span class="i">end</span>;
<span class="i">end</span>;

<span class="c">// Funkcja oblicza liczbê spójnych sk³adowych w grafie</span>
<span class="c">// n    - liczba wierzcho³ków w grafie</span>
<span class="c">// graf - tablica list s±siedztwa</span>
<span class="c">// VU   - tablica dostêpno¶ci krawêdzi grafu</span>
<span class="c">//----------------------------------------------------</span>
<span class="i">function</span> <span class="v">ccn</span>(<span class="v">n</span> : <span class="v">integer</span>; <span class="i">var</span> <span class="v">graf</span> : <span class="v">TList</span>; <span class="v">VU</span> : <span class="i">array</span> <span class="i">of</span> <span class="v">boolean</span>) : <span class="v">integer</span>;
<span class="i">var</span>
  <span class="v">C</span>        : <span class="i">array</span> <span class="i">of</span> <span class="v">integer</span>;
  <span class="v">S</span>        : <span class="v">stack</span>;
  <span class="v">cc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span> : <span class="v">integer</span>;
  <span class="v">p</span>        : <span class="v">PslistEl</span>;

<span class="i">begin</span>
  <span class="v">S</span>.<span class="v">init</span>;                    <span class="c">// Tworzymy pusty stos</span>
  <span class="v">SetLength</span>(<span class="v">C</span>,<span class="v">n</span>);            <span class="c">// Tworzymy tablicê spójnych sk³adowych</span>
  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
    <span class="v">C</span>[<span class="v">i</span>] := <span class="n">0</span>;               <span class="c">// Zerujemy tablicê spójnych sk³adowych</span>

  <span class="v">cc</span> := <span class="n">0</span>;                   <span class="c">// Zerujemy licznik spójnych sk³adowych</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
    <span class="i">if</span> <span class="v">VU</span>[<span class="v">i</span>] <span class="i">and</span> (<span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>) <span class="i">then</span> <span class="c">// Szukamy nieodwiedzonego jeszcze wierzcho³ka</span>
    <span class="i">begin</span>
      <span class="v">inc</span>(<span class="v">cc</span>);               <span class="c">// Zwiêkszamy licznik sk³adowych</span>
      <span class="v">S</span>.<span class="v">push</span>(<span class="v">i</span>);             <span class="c">// Na stosie umieszczamy numer bie¿±cego wêz³a</span>
      <span class="v">C</span>[<span class="v">i</span>] := <span class="v">cc</span>;            <span class="c">// Wierzcho³ek numerujemy i oznaczamy jako odwiedzony</span>
      <span class="i">while</span> <span class="i">not</span> <span class="v">S</span>.<span class="v">empty</span> <span class="i">do</span>   <span class="c">// Przechodzimy graf algorytmem DFS</span>
      <span class="i">begin</span>
        <span class="v">v</span> := <span class="v">S</span>.<span class="v">top</span>();        <span class="c">// Pobieramy wierzcho³ek</span>
        <span class="v">S</span>.<span class="v">pop</span>();             <span class="c">// Usuwamy go ze stosu</span>
        <span class="v">p</span> := <span class="v">graf</span>[<span class="v">v</span>];        <span class="c">// Przegl±damy s±siadów wierzcho³ka v</span>
        <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
        <span class="i">begin</span>
          <span class="v">u</span> := <span class="v">p</span>^.<span class="v">v</span>;
          <span class="i">if</span> <span class="v">VU</span>[<span class="v">u</span>] <span class="i">and</span> (<span class="v">C</span>[<span class="v">u</span>] = <span class="n">0</span>) <span class="i">then</span>
          <span class="i">begin</span>
            <span class="v">S</span>.<span class="v">push</span>(<span class="v">u</span>);       <span class="c">// Na stos id± s±siedzi nieodwiedzeni</span>
            <span class="v">C</span>[<span class="v">u</span>] := <span class="v">cc</span>       <span class="c">// i ponumerowani</span>
          <span class="i">end</span>;
          <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;
        <span class="i">end</span>;
      <span class="i">end</span>;
    <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">C</span>,<span class="n">0</span>);           <span class="c">// Usuwamy tablicê C</span>
  <span class="v">S</span>.<span class="v">destroy</span>;                <span class="c">// Usuwamy stos</span>
  <span class="v">ccn</span> := <span class="v">cc</span>;                <span class="c">// Zwracamy wynik</span>
<span class="i">end</span>;

<span class="c">// **********************</span>
<span class="c">// *** Program g³ówny ***</span>
<span class="c">// **********************</span>

<span class="i">var</span>
  <span class="v">n</span>,<span class="v">m</span>      : <span class="v">integer</span>;       <span class="c">// Liczba wierzcho³ków i krawêdzi</span>
  <span class="v">A</span>        : <span class="v">TList</span>;         <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">nc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span> : <span class="v">integer</span>;
  <span class="v">L</span>,<span class="v">p</span>,<span class="v">r</span>    : <span class="v">PslistEl</span>;
  <span class="v">VU</span>       : <span class="i">array</span> <span class="i">of</span> <span class="v">boolean</span>;

<span class="i">begin</span>
  <span class="v">read</span>(<span class="v">n</span>,<span class="v">m</span>);                 <span class="c">// Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

  <span class="v">SetLength</span>(<span class="v">A</span>,<span class="v">n</span>);            <span class="c">// Tworzymy tablice dynamiczne</span>
  <span class="v">SetLength</span>(<span class="v">VU</span>,<span class="v">n</span>);

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">A</span>[<span class="v">i</span>]  := <span class="v">nil</span>;
    <span class="v">VU</span>[<span class="v">i</span>] := <span class="v">true</span>;
  <span class="i">end</span>;

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">m</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">read</span>(<span class="v">v</span>,<span class="v">u</span>);               <span class="c">// Wierzcho³ki tworz±ce krawêd¼</span>
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// Tworzymy nowy element</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">u</span>;               <span class="c">// Numerujemy go jako w</span>
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">A</span>[<span class="v">v</span>];         <span class="c">// Dodajemy go na pocz±tek listy A[v]</span>
    <span class="v">A</span>[<span class="v">v</span>] := <span class="v">p</span>;
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// To samo dla krawêdzi w drug± stronê</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">A</span>[<span class="v">u</span>];
    <span class="v">A</span>[<span class="v">u</span>] := <span class="v">p</span>;
  <span class="i">end</span>;

  <span class="c">// Algorytm znajdowania punktów artykulacji</span>

  <span class="v">L</span> := <span class="v">nil</span>;                  <span class="c">// Pusta lista punktów artykulacji</span>

  <span class="v">nc</span> := <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>);         <span class="c">// Zapamiêtujemy liczbê spójnych sk³adowych</span>

  <span class="i">for</span> <span class="v">v</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>     <span class="c">// Przechodzimy przez kolejne wierzcho³ki grafu</span>
  <span class="i">begin</span>
    <span class="v">VU</span>[<span class="v">v</span>] := <span class="v">false</span>;          <span class="c">// Zaznaczamy wierzcho³ek v jako usuniêty</span>
    <span class="i">if</span> <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>) &gt; <span class="v">nc</span> <span class="i">then</span> <span class="c">// Sprawdzamy, czy v jest punktem artykulacji</span>
    <span class="i">begin</span>
      <span class="v">new</span>(<span class="v">p</span>);                <span class="c">// Je¶li tak, do³±czamy go do listy</span>
      <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
      <span class="v">p</span>^.<span class="v">next</span> := <span class="v">L</span>;
      <span class="v">L</span> := <span class="v">p</span>;
    <span class="i">end</span>;
    <span class="v">VU</span>[<span class="v">v</span>] := <span class="v">true</span>;           <span class="c">// Odtwarzamy wierzcho³ek</span>
  <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="c">// Wypisujemy znalezione punkty artykulacji, jednocze¶nie usuwaj±c listê L</span>

  <span class="i">while</span> <span class="v">L</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">write</span>(<span class="v">L</span>^.<span class="v">v</span>,<span class="t">' '</span>);
    <span class="v">p</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">L</span>^.<span class="v">next</span>;
    <span class="v">dispose</span>(<span class="v">p</span>);
  <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="c">// Usuwamy pozosta³e struktury dynamiczne</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">p</span> := <span class="v">A</span>[<span class="v">i</span>];
    <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">r</span> := <span class="v">p</span>;
      <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;
      <span class="v">dispose</span>(<span class="v">r</span>);
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">A</span>,<span class="n">0</span>);
  <span class="v">SetLength</span>(<span class="v">VU</span>,<span class="n">0</span>);

<span class="i">end</span>. </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Code::Blocks</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="cpp"><pre><span class="c">// Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">// Data: 29.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//---------------------------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy punktów artykulacji</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>;
};

<span class="i">class</span> <span class="v">stack</span>
{
  <span class="i">private</span>:
    <span class="v">slistEl</span> * <span class="v">S</span>;   <span class="c">// lista przechowuj±ca stos</span>

  <span class="i">public</span>:
    <span class="v">stack</span>();       <span class="c">// konstruktor</span>
    ~<span class="v">stack</span>();      <span class="c">// destruktor</span>
    <span class="i">bool</span> <span class="v">empty</span>(<span class="i">void</span>);
    <span class="i">int</span>  <span class="v">top</span>(<span class="i">void</span>);
    <span class="i">void</span> <span class="v">push</span>(<span class="i">int</span> <span class="v">v</span>);
    <span class="i">void</span> <span class="v">pop</span>(<span class="i">void</span>);
};

<span class="c">//---------------------</span>
<span class="c">// Metody obiektu stack</span>
<span class="c">//---------------------</span>

<span class="c">// Konstruktor</span>
<span class="c">//------------</span>
<span class="v">stack</span>::<span class="v">stack</span>()
{
  <span class="v">S</span> = <span class="v">NULL</span>;
}

<span class="c">// Destruktor - zwalnia tablicê dynamiczn±</span>
<span class="c">//----------------------------------------</span>
<span class="v">stack</span>::~<span class="v">stack</span>()
{
  <span class="i">while</span>(<span class="v">S</span>) <span class="v">pop</span>();
}

<span class="c">// Sprawdza, czy stos jest pusty</span>
<span class="c">//------------------------------</span>
<span class="i">bool</span> <span class="v">stack</span>::<span class="v">empty</span>(<span class="i">void</span>)
{
  <span class="i">return</span> !<span class="v">S</span>;
}

<span class="c">// Zwraca szczyt stosu</span>
<span class="c">//--------------------</span>
<span class="i">int</span> <span class="v">stack</span>::<span class="v">top</span>(<span class="i">void</span>)
{
  <span class="i">return</span> <span class="v">S</span>-&gt;<span class="v">v</span>;
}

<span class="c">// Zapisuje na stos</span>
<span class="c">//-----------------</span>
<span class="i">void</span> <span class="v">stack</span>::<span class="v">push</span>(<span class="i">int</span> <span class="v">v</span>)
{
  <span class="v">slistEl</span> * <span class="v">e</span> = <span class="i">new</span> <span class="v">slistEl</span>;
  <span class="v">e</span>-&gt;<span class="v">v</span>    = <span class="v">v</span>;
  <span class="v">e</span>-&gt;<span class="v">next</span> = <span class="v">S</span>;
  <span class="v">S</span> = <span class="v">e</span>;
}

<span class="c">// Usuwa ze stosu</span>
<span class="c">//---------------</span>
<span class="i">void</span> <span class="v">stack</span>::<span class="v">pop</span>(<span class="i">void</span>)
{
  <span class="i">if</span>(<span class="v">S</span>)
  {
    <span class="v">slistEl</span> * <span class="v">e</span> = <span class="v">S</span>;
    <span class="v">S</span> = <span class="v">S</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> <span class="v">e</span>;
  }
}

<span class="c">// Funkcja oblicza liczbê spójnych sk³adowych w grafie</span>
<span class="c">// n    - liczba wierzcho³ków w grafie</span>
<span class="c">// graf - tablica list s±siedztwa</span>
<span class="c">// VU   - tablica dostêpno¶ci krawêdzi grafu</span>
<span class="c">//----------------------------------------------------</span>
<span class="i">int</span> <span class="v">ccn</span>(<span class="i">int</span> <span class="v">n</span>, <span class="v">slistEl</span> ** <span class="v">graf</span>, <span class="i">bool</span> * <span class="v">VU</span>)
{
  <span class="i">int</span> * <span class="v">C</span>,<span class="v">cc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>;
  <span class="v">stack</span> <span class="v">S</span>;
  <span class="v">slistEl</span> * <span class="v">p</span>;

  <span class="v">C</span> = <span class="i">new</span> <span class="i">int</span>[<span class="v">n</span>];            <span class="c">// Tworzymy tablicê spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++) <span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>; <span class="c">// Zerujemy tablicê spójnych sk³adowych</span>

  <span class="v">cc</span> = <span class="n">0</span>;                    <span class="c">// Zerujemy licznik spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
    <span class="i">if</span>(<span class="v">VU</span>[<span class="v">i</span>] &amp;&amp; !<span class="v">C</span>[<span class="v">i</span>])       <span class="c">// Szukamy nieodwiedzonego jeszcze wierzcho³ka</span>
    {
      <span class="v">cc</span>++;                  <span class="c">// Zwiêkszamy licznik sk³adowych</span>
      <span class="v">S</span>.<span class="v">push</span>(<span class="v">i</span>);             <span class="c">// Na stosie umieszczamy numer bie¿±cego wêz³a</span>
      <span class="v">C</span>[<span class="v">i</span>] = <span class="v">cc</span>;             <span class="c">// Wierzcho³ek numerujemy i oznaczamy jako odwiedzony</span>
      <span class="i">while</span>(!<span class="v">S</span>.<span class="v">empty</span>())      <span class="c">// Przechodzimy graf algorytmem DFS</span>
      {
        <span class="v">v</span> = <span class="v">S</span>.<span class="v">top</span>();         <span class="c">// Pobieramy wierzcho³ek</span>
        <span class="v">S</span>.<span class="v">pop</span>();             <span class="c">// Usuwamy go ze stosu</span>
        <span class="i">for</span>(<span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]; <span class="v">p</span>; <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>) <span class="c">// Przegl±damy s±siadów wierzcho³ka v</span>
        {
          <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;
          <span class="i">if</span>(<span class="v">VU</span>[<span class="v">u</span>] &amp;&amp; !<span class="v">C</span>[<span class="v">u</span>])
          {
            <span class="v">S</span>.<span class="v">push</span>(<span class="v">u</span>);       <span class="c">// Na stos id± s±siedzi nieodwiedzeni</span>
            <span class="v">C</span>[<span class="v">u</span>] = <span class="v">cc</span>;       <span class="c">// i ponumerowani</span>
          }
        }
      }
    }

  <span class="i">delete</span> [] <span class="v">C</span>;               <span class="c">// Usuwamy tablicê C</span>
  <span class="i">return</span> <span class="v">cc</span>;                 <span class="c">// Zwracamy wynik</span>
}

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">n</span>,<span class="v">m</span>;                   <span class="c">// Liczba wierzcho³ków i krawêdzi</span>
  <span class="v">slistEl</span> ** <span class="v">A</span>;              <span class="c">// Tablica list s±siedztwa</span>
  <span class="i">int</span> <span class="v">nc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>;
  <span class="v">slistEl</span> * <span class="v">L</span>,* <span class="v">p</span>,* <span class="v">r</span>;
  <span class="i">bool</span> * <span class="v">VU</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Czytamy liczbê wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy zmienne dynamiczne</span>

  <span class="v">VU</span> = <span class="i">new</span> <span class="i">bool</span>[<span class="v">n</span>];          <span class="c">// Krawêdzie aktywne</span>
  <span class="v">A</span>  = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>];    <span class="c">// Tablica list s±siedztwa</span>

  <span class="c">// Tablicê wype³niamy pustymi listami</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">A</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
    <span class="v">VU</span>[<span class="v">i</span>] = <span class="i">true</span>;
  }

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">u</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">A</span>[<span class="v">v</span>];
    <span class="v">A</span>[<span class="v">v</span>] = <span class="v">p</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">A</span>[<span class="v">u</span>];
    <span class="v">A</span>[<span class="v">u</span>] = <span class="v">p</span>;
  }

  <span class="c">// Algorytm znajdowania punktów artykulacji</span>

  <span class="v">L</span> = <span class="v">NULL</span>;                  <span class="c">// Pusta lista punktów artykulacji</span>

  <span class="v">nc</span> = <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>);          <span class="c">// Zapamiêtujemy liczbê spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">v</span> = <span class="n">0</span>; <span class="v">v</span> &lt; <span class="v">n</span>; <span class="v">v</span>++)     <span class="c">// Przechodzimy przez kolejne wierzcho³ki grafu</span>
  {
    <span class="v">VU</span>[<span class="v">v</span>] = <span class="i">false</span>;           <span class="c">// Zaznaczamy wierzcho³ek v jako usuniêty</span>
    <span class="i">if</span>(<span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>) &gt; <span class="v">nc</span>)     <span class="c">// Sprawdzamy, czy v jest punktem artykulacji</span>
    {
      <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;       <span class="c">// Je¶li tak, do³±czamy go do listy</span>
      <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
      <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
      <span class="v">L</span> = <span class="v">p</span>;
    }
    <span class="v">VU</span>[<span class="v">v</span>] = <span class="i">true</span>;            <span class="c">// Odtwarzamy wierzcho³ek</span>
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Wypisujemy znalezione punkty artykulacji, jednocze¶nie usuwaj±c listê L</span>

  <span class="i">while</span>(<span class="v">L</span>)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">L</span>-&gt;<span class="v">v</span> &lt;&lt; <span class="t">" "</span>;
    <span class="v">p</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> [] <span class="v">p</span>;
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Usuwamy dynamiczne struktury danych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">p</span> = <span class="v">A</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">p</span>)
    {
      <span class="v">r</span> = <span class="v">p</span>;
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">r</span>;
    }
  }

  <span class="i">delete</span> [] <span class="v">A</span>;
  <span class="i">delete</span> [] <span class="v">VU</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Free Basic</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="bas"><pre><span class="c">' Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">' Data: 29.12.2013</span>
<span class="c">' (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">'---------------------------------------------------------</span>

<span class="c">' Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy punktów artykulacji</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Next</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="i">Type</span> <span class="v">stack</span>
  <span class="i">Private</span>:
    <span class="v">S</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>  <span class="c">' lista zawieraj±ca stos</span>
  <span class="i">Public</span>:
    <span class="i">Declare</span> <span class="i">Constructor</span>()
    <span class="i">Declare</span> <span class="i">Destructor</span>()
    <span class="i">Declare</span> <span class="i">Function</span> <span class="v">empty</span>() <span class="i">As</span> <span class="i">Integer</span>
    <span class="i">Declare</span> <span class="i">Function</span> <span class="v">top</span> <span class="i">As</span> <span class="i">Integer</span>
    <span class="i">Declare</span> <span class="i">Sub</span> <span class="v">push</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>)
    <span class="i">Declare</span> <span class="i">Sub</span> <span class="v">pop</span>()
<span class="i">End</span> <span class="i">Type</span>

<span class="c">'---------------------</span>
<span class="c">' Metody obiektu stack</span>
<span class="c">'---------------------</span>

<span class="c">' Konstruktor</span>
<span class="c">'------------</span>
<span class="i">Constructor</span> <span class="v">stack</span>()
  <span class="v">S</span> = <span class="n">0</span>
<span class="i">End</span> <span class="i">Constructor</span>

<span class="c">' Destruktor</span>
<span class="c">'-----------</span>
<span class="i">Destructor</span> <span class="v">stack</span>()
  <span class="i">While</span> <span class="v">S</span>
  	 <span class="v">pop</span>()
  <span class="i">Wend</span>
<span class="i">End</span> <span class="i">Destructor</span>

<span class="c">' Sprawdza, czy stos jest pusty</span>
<span class="c">'------------------------------</span>
<span class="i">Function</span> <span class="v">stack</span>.<span class="v">empty</span>() <span class="i">As</span> <span class="i">Integer</span>
  <span class="i">If</span> <span class="v">S</span> = <span class="n">0</span> <span class="i">Then</span> <span class="i">Return</span> <span class="n">1</span>
  <span class="i">Return</span> <span class="n">0</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' Zwraca szczyt stosu.</span>
<span class="c">'------------------------------</span>
<span class="i">Function</span> <span class="v">stack</span>.<span class="v">top</span>() <span class="i">As</span> <span class="i">Integer</span>
  <span class="v">top</span> = <span class="v">S</span>-&gt;<span class="v">v</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' Zapisuje na stos</span>
<span class="c">'-----------------</span>
<span class="i">Sub</span> <span class="v">stack</span>.<span class="v">push</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>)
  <span class="i">Dim</span> <span class="v">e</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">e</span> = <span class="i">New</span> <span class="v">slistEl</span>
  <span class="v">e</span>-&gt;<span class="v">v</span>    = <span class="v">v</span>
  <span class="v">e</span>-&gt;<span class="i">Next</span> = <span class="v">S</span>
  <span class="v">S</span> = <span class="v">e</span>
<span class="i">End</span> <span class="i">Sub</span>

<span class="c">' Usuwa ze stosu</span>
<span class="c">'---------------</span>
<span class="i">Sub</span> <span class="v">stack</span>.<span class="v">pop</span>()
  <span class="i">Dim</span> <span class="v">e</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="i">If</span> <span class="v">S</span> <span class="i">Then</span>
    <span class="v">e</span> = <span class="v">S</span>
    <span class="v">S</span> = <span class="v">S</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">e</span>
  <span class="i">End</span> <span class="i">If</span>
<span class="i">End</span> <span class="i">Sub</span>

<span class="c">' Funkcja oblicza liczbê spójnych sk³adowych w grafie</span>
<span class="c">' n    - liczba wierzcho³ków w grafie</span>
<span class="c">' graf - tablica list s±siedztwa</span>
<span class="c">' VU   - tablica dostêpno¶ci krawêdzi grafu</span>
<span class="c">'----------------------------------------------------</span>
<span class="i">Function</span> <span class="v">ccn</span>(<span class="i">Byval</span> <span class="v">n</span> <span class="i">As</span> <span class="i">Integer</span>, <span class="i">Byval</span> <span class="v">graf</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span>, <span class="i">Byval</span> <span class="v">VU</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span>) <span class="i">As</span> <span class="i">Integer</span>

  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">C</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">cc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">stack</span> <span class="v">S</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>

  <span class="v">C</span> = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]        <span class="c">' Tworzymy tablicê spójnych sk³adowych</span>

  <span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
    <span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>                 <span class="c">' Zerujemy tablicê spójnych sk³adowych</span>
  <span class="i">Next</span>

  <span class="v">cc</span> = <span class="n">0</span>                     <span class="c">' Zerujemy licznik spójnych sk³adowych</span>

  <span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
    <span class="i">If</span> (<span class="v">VU</span>[<span class="v">i</span>] = <span class="n">1</span>) <span class="i">Andalso</span> (<span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>) <span class="i">Then</span> <span class="c">' Szukamy nieodwiedzonego jeszcze wierzcho³ka</span>
      <span class="v">cc</span> += <span class="n">1</span>                <span class="c">' Zwiêkszamy licznik sk³adowych</span>
      <span class="v">S</span>.<span class="v">push</span>(<span class="v">i</span>)              <span class="c">' Na stosie umieszczamy numer bie¿±cego wêz³a</span>
      <span class="v">C</span>[<span class="v">i</span>] = <span class="v">cc</span>              <span class="c">' Wierzcho³ek numerujemy i oznaczamy jako odwiedzony      </span>
      <span class="i">While</span> <span class="v">S</span>.<span class="v">empty</span>() = <span class="n">0</span>    <span class="c">' Przechodzimy graf algorytmem DFS</span>
        <span class="v">v</span> = <span class="v">S</span>.<span class="v">top</span>()          <span class="c">' Pobieramy wierzcho³ek</span>
        <span class="v">S</span>.<span class="v">pop</span>()              <span class="c">' Usuwamy go ze stosu</span>
        <span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]          <span class="c">' Przegl±damy s±siadów wierzcho³ka v</span>
        <span class="i">While</span> <span class="v">p</span>
          <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>
          <span class="i">If</span> (<span class="v">VU</span>[<span class="v">u</span>] = <span class="n">1</span>) <span class="i">Andalso</span> (<span class="v">C</span>[<span class="v">u</span>] = <span class="n">0</span>) <span class="i">Then</span>
            <span class="v">S</span>.<span class="v">push</span>(<span class="v">u</span>)        <span class="c">' Na stos id± s±siedzi nieodwiedzeni</span>
            <span class="v">C</span>[<span class="v">u</span>] = <span class="v">cc</span>        <span class="c">' i ponumerowani</span>
          <span class="i">End</span> <span class="i">If</span> 
          <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
        <span class="i">Wend</span>
      <span class="i">Wend</span>
    <span class="i">End</span> <span class="i">If</span>
  <span class="i">Next</span>
  
  <span class="i">Delete</span> [] <span class="v">C</span>                <span class="c">' Usuwamy tablicê C</span>

  <span class="i">Return</span> <span class="v">cc</span>                  <span class="c">' Zwracamy wynik</span>

<span class="i">End</span> <span class="i">Function</span>

<span class="c">' **********************</span>
<span class="c">' *** Program g³ówny ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">nc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">A</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">L</span>,<span class="v">p</span>,<span class="v">r</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span> <span class="v">VU</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">n</span>,<span class="v">m</span>                 <span class="c">' Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

<span class="v">A</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]      <span class="c">' Tworzymy tablice dynamiczne</span>
<span class="v">VU</span> = <span class="i">New</span> <span class="i">Byte</span> [<span class="v">n</span>]            <span class="c">' Krawêdzie aktywne</span>

<span class="c">' Tablicê A wype³niamy pustymi listami, a tablicê C wype³niamy zerami</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">A</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">VU</span>[<span class="v">i</span>] = <span class="n">1</span>
<span class="i">Next</span>

<span class="c">' Odczytujemy kolejne definicje krawêdzi.</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">u</span>               <span class="c">' Wierzcho³ki tworz±ce krawêd¼</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' Tworzymy nowy element</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>                   <span class="c">' Numerujemy go jako u</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">A</span>[<span class="v">v</span>]             <span class="c">' Dodajemy go na pocz±tek listy A[v]</span>
  <span class="v">A</span>[<span class="v">v</span>] = <span class="v">p</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' To samo dla krawêdzi w drug± stronê</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">A</span>[<span class="v">u</span>]
  <span class="v">A</span>[<span class="v">u</span>] = <span class="v">p</span>
<span class="i">Next</span>

<span class="c">' Algorytm znajdowania punktów artykulacji</span>

<span class="v">L</span> = <span class="n">0</span>                        <span class="c">' Pusta lista punktów artykulacji</span>

<span class="v">nc</span> = <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>)             <span class="c">' Zapamiêtujemy liczbê spójnych sk³adowych</span>

<span class="i">For</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>           <span class="c">' Przechodzimy przez kolejne wierzcho³ki grafu</span>
  <span class="v">VU</span>[<span class="v">v</span>] = <span class="n">0</span>                  <span class="c">' Zaznaczamy wierzcho³ek v jako usuniêty</span>
  <span class="i">If</span> <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>) &gt; <span class="v">nc</span> <span class="i">Then</span>   <span class="c">' Sprawdzamy, czy v jest punktem artykulacji</span>
    <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>          <span class="c">' Je¶li tak, do³±czamy go do listy</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
    <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
    <span class="v">L</span> = <span class="v">p</span>
  <span class="i">End</span> <span class="i">If</span>
  <span class="v">VU</span>[<span class="v">v</span>] = <span class="n">1</span>                  <span class="c">' Odtwarzamy wierzcho³ek</span>
<span class="i">Next</span>

<span class="i">Print</span>

<span class="c">' Wypisujemy znalezione punkty artykulacji, jednocze¶nie usuwaj±c listê L</span>

<span class="i">While</span> <span class="v">L</span>
  <span class="i">Print</span> <span class="v">L</span>-&gt;<span class="v">v</span>;
  <span class="v">p</span> = <span class="v">L</span>
  <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="i">Next</span>
  <span class="i">Delete</span> [] <span class="v">p</span>
<span class="i">Wend</span>

<span class="i">Print</span>

<span class="c">' Usuwamy dynamiczne struktury danych</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">p</span> = <span class="v">A</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">r</span> = <span class="v">p</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">r</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">A</span>
<span class="i">Delete</span> [] <span class="v">VU</span>

<span class="i">End</span> </pre></pre></td>
		</tr>
		<tr>
			<td style="text-align: center" bgcolor="#F0F0F0" colspan="2"><b>Wynik</b></td>
		</tr>
		<tr>
			<td style="text-align: left" class="program">8 11<br>0 1 0 2 0 3 0 5<br>1 4 1 5<br>2 3<br>3 6 3 7<br>4 5<br>6 7<br>
			<br>3 0</td>
			<td style="text-align: center">
			<img src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_03.gif" width="243" height="148"></td>
		</tr>
	</tbody></table>
	</div>
	</div>
	<p>&nbsp;</p><h3><a name="P2"></a>Rozwi±zanie nr 2</h3>
<div class="sb1">Do szybkiego wyszukiwania punktów artykulacji wykorzystujemy 
	podobny algorytm jak do wyszukiwania <a href="https://eduinf.waw.pl/inf/alg/001_search/0130a.php#P2">mostów</a>. Idea 
	tego algorytmu równie¿ opiera siê na drzewie rozpinaj±cym grafu oraz na 
	przej¶ciu wstecznym za pomoc± DFS. W algorytmie wykorzystuje siê dwie 
	w³asno¶ci punktów artykulacji:<p>&nbsp;</p>
	<p>
	<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_04.gif" width="210" height="234" style="float: left; margin-right: 16"></p>
	<div class="bl1"><font color="#FF0000">Korzeñ drzewa rozpinaj±cego w g³±b 
		grafu jest punktem artykulacji tylko wtedy, je¶li posiada co najmniej 
		dwóch synów</font>. Uzasadnienie tego faktu jest bardzo proste. Gdy 
		uruchomimy przej¶cie DFS przy tworzeniu drzewa rozpinaj±cego, to dojdzie 
		ono do ka¿dego wierzcho³ka, do którego istnieje w grafie ¶cie¿ka od 
		wierzcho³ka startowego. Zatem po uruchomieniu w korzeniu drzewa DFS 
		odwiedzi wszystkich s±siadów korzenia, do których w grafie istnieje 
		¶cie¿ka. Je¶li jaki¶ s±siad zostanie nieodwiedzony przy powrocie z DFS 
		uruchomionego dla pierwszego z synów, to znaczy, ¿e w grafie nie by³o do 
		niego innej ¶cie¿ki oprócz krawêdzi bezpo¶rednio od korzenia do tego 
		s±siada. W takim przypadku powstaje kolejny syn korzenia
		<span class="rem">(gdy¿ DFS musimy ponownie uruchomiæ dla ka¿dego 
		nieodwiedzonego s±siada)</span>. Pomiêdzy poprzednim synem istnieje 
		droga tylko poprzez korzeñ drzewa <span class="rem">(gdyby istnia³a 
		inna, to DFS by j± znalaz³o i dany wierzcho³ek nie zosta³by synem 
		korzenia, lecz jego dalszym potomkiem)</span>. Je¶li korzeñ zostanie 
		teraz usuniêty z grafu, to wszyscy jego synowie na drzewie rozpinaj±cym 
		znajd± siê w oddzielnych spójnych sk³adowych grafu. Liczba tych 
		sk³adowych wzro¶nie, zatem korzeñ bêdzie punktem artykulacji.<p>&nbsp;</p></div>
	<p>
	<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_05.gif" width="222" height="262" style="float: right; margin-left: 16"></p><div class="bl1">
		<font color="#FF0000">Wierzcho³ek nie bêd±cy korzeniem drzewa 
		rozpinaj±cego w g³±b jest punktem artykulacji, je¶li przynajmniej dla 
		jednego z jego synów nie istnieje krawêd¼ wtórna, która ³±czy potomka 
		tego wierzcho³ka z jego przodkiem</font>. Wyja¶nienie jest równie¿ 
		proste. Istnienie krawêdzi wtórnej oznacza, ¿e do syna mo¿na doj¶æ 
		równie¿ inn± drog±, która nie wiedzie poprzez dany wierzcho³ek. Skoro 
		tak, to jego usuniêcie nie od³±czy syna od reszty grafu, gdy¿ wci±¿ 
		bêdzie siê znajdowa³ w tej samej spójnej sk³adowej z uwagi na krawêd¼ 
		³±cz±c± jego potomków z innym przodkiem. Zatem liczba sk³adowych nie 
		wzro¶nie. Je¶li natomiast taka krawêd¼ wtórna nie istnieje, to do tego 
		syna mo¿na przej¶æ w grafie tylko krawêdzi±, która ³±czy go z jego 
		ojcem. Je¶li usuniemy ojca, krawêd¼ zniknie i syn znajdzie siê w oddzielnej spójnej 
		sk³adowej. Liczba sk³adowych grafu wzro¶nie, zatem ojciec musi byæ 
		punktem artykulacji.</div>
	<p>&nbsp;</p>
	<p>Sprawdzenie pierwszej w³asno¶ci jest proste. Drug± w³asno¶æ sprawdzamy 
	nastêpuj±co:</p><div class="bl1">&nbsp;<p>Przechodzimy przez graf algorytmem 
		DFS, numeruj±c po drodze wszystkie odwiedzone wierzcho³ki oraz 
		obliczaj±c dla nich parametr Low po odwiedzeniu wszystkich s±siadów. 
		Przypomnijmy, parametr Low jest najmniejsz± warto¶ci± z numerów nadanych 
		przez DFS bie¿±cemu wierzcho³kowi, wierzcho³kowi po³±czonemu z bie¿±cym 
		krawêdzi± wtórn± oraz parametrom Low wszystkich synów na drzewie 
		rozpinaj±cym. Czym dok³adnie jest ten parametr dla danego wierzcho³ka? 
		Otó¿ jest to najmniejszy numer nadany przez DFS wierzcho³kowi, do 
		którego istnieje ¶cie¿ka w dó³ drzewa <span class="rem">(pó¼niej ¶cie¿ka 
		ta mo¿e zawracaæ i tworzyæ cykl)</span>. Je¶li parametr Low dla jednego 
		z synów bêdzie wiêkszy lub równy numerowi DFS bie¿±cego wierzcho³ka, to 
		bêdzie to oznacza³o, ¿e ¶cie¿ka zawieraj±ca wierzcho³ek bie¿±cy i tego 
		syna nie posiada krawêdzi wtórnej do przodka wierzcho³ka bie¿±cego
		<span class="rem">(w takim przypadku parametr Low syna by³by mniejszy od 
		numeru DFS jego ojca)</span>. Skoro tak, to wierzcho³ek bie¿±cy jest 
		punktem artykulacji.</p></div>
	<p>&nbsp;</p>
	<p>Zobaczmy na prostym przyk³adzie, jak dzia³a algorytm Tarjana:</p>
	<p>&nbsp;</p>
	<table border="0" cellpadding="4" cellspacing="0" class="sb1">
		<tbody><tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_06.gif" width="121" height="196"></td>
			<td nowrap=""><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td>Oto nasz przyk³adowy graf, w którym mamy znale¼æ wszystkie 
			punkty artykulacji. Graf przejdziemy algorytmem DFS, tworz±c po drodze drzewo 
			rozpinaj±ce w g³±b oraz numeruj±c wierzcho³ki grafu
			<span class="rem">(numeracja DFS nie ma nic wspólnego z numerami 
			wierzcho³ków w definicji grafu &#8211; okre¶la ona kolejno¶æ 
			odwiedzin poszczególnych wierzcho³ków)</span>. Numery te pos³u¿± 
			pó¼niej do wyznaczenia dla ka¿dego wierzcho³ka parametru Low, gdy 
			zostan± ju¿ przetworzeni wszyscy s±siedzi.</td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_07.gif" width="121" height="196"></td>
			<td nowrap="">&nbsp;</td>
			<td>Rozpoczynamy od wierzcho³ka 0 <span class="rem">(punkt startowy nie ma wp³ywu na 
			wynik pracy algorytmu)</span>. Wierzcho³ek zaznaczamy jako odwiedzony i 
			nadajemy mu numer DFS 1.<p>Wierzcho³ek posiada trzech 
			nieodwiedzonych jeszcze s±siadów: 1, 2 i 3.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_08.gif" width="130" height="195"></td>
			<td nowrap="">&nbsp;</td>
			<td>Odwiedzamy wierzcho³ek nr 1. Oznaczamy go jako odwiedzony i 
			nadajemy mu numer DFS 2. Krawêd¼ 0 &#8211; 1 staje siê krawêdzi± 
			drzewa rozpinaj±cego w g³±b. Wierzcho³ek 0 jest korzeniem drzewa, 
			wierzcho³ek 1 jest jego synem.<p>Wierzcho³ek posiada jednego 
			nieodwiedzonego s±siada: 2.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_09.gif" width="130" height="195"></td>
			<td nowrap="">&nbsp;</td>
			<td>Odwiedzamy wierzcho³ek 2. Oznaczamy go jako odwiedzony i 
			nadajemy mu numer DFS 3. Krawêd¼ 1 &#8211; 2 zostaje dopisana do 
			drzewa rozpinaj±cego <span class="rem">(1 jest ojcem, 2 jest synem)</span>.<p>
			Wierzcho³ek 2 nie posiada ju¿ nieodwiedzonych s±siadów. Wierzcho³ek 
			nie ma synów, nie mo¿e byæ zatem punktem artykulacji. Przetwarzamy 
			go, obliczaj±c parametr Low jako najmniejsz± liczbê z 3
			<span class="rem">(numer DFS wierzcho³ka)</span> i 1
			<span class="rem">(numer DFS wierzcho³ka 0, który ³±czy siê 
			krawêdzi± wtórn±)</span>. Wierzcho³ek 2 nie posiada synów na drzewie 
			rozpinaj±cym.</p>
			<p>Low(2) = min (3,1) = 1</p>
			<p>Wracamy do wierzcho³ka nr 1.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_10.gif" width="141" height="196"></td>
			<td nowrap="">&nbsp;</td>
			<td>Jeste¶my z powrotem w wierzcho³ku nr 1. Wierzcho³ek posiada syna 
			nr 2, lecz parametr Low(2) = 1 jest mniejszy od numeru DSF 
			wierzcho³ka nr 1 równego 2 <span class="rem">a oznacza to, ¿e 
			istnieje krawêd¼ wtórna ³±cz±ca potomka (2) z przodkiem (0): tutaj 
			jest to krawêd¼ 2 &#8211; 0)</span>. Zatem wierzcho³ek ten nie mo¿e 
			byæ punktem artykulacji.<p>Poniewa¿ wszyscy s±siedzi zostali ju¿ 
			odwiedzeni, przetwarzamy wierzcho³ek, obliczaj±c dla niego parametr 
			Low. Bêdzie to najmniejsza warto¶æ z 2 <span class="rem">(numer DFS 
			wierzcho³ka)</span> i 1 <span class="rem">(parametr Low dla jego 
			syna 2)</span>.</p>
			<p>Low(1) = min (2,1) = 1.</p>
			<p>Wracamy do wierzcho³ka 0.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_11.gif" width="141" height="196"></td>
			<td nowrap="">&nbsp;</td>
			<td>Odwiedzamy ostatniego s±siada wierzcho³ka 0, czyli wierzcho³ek 
			nr 3. Oznaczamy go jako odwiedzony i nadajemy mu numer DFS 4. 
			Krawêd¼&nbsp; 0 &#8211; 3 zostaje dopisana do drzewa rozpinaj±cego.<p>
			Wierzcho³ek nr 3 ma dwóch nieodwiedzonych s±siadów: 4 i 5.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_12.gif" width="141" height="197"></td>
			<td nowrap="">&nbsp;</td>
			<td>Odwiedzamy wierzcho³ek nr 4. Oznaczamy go jako odwiedzonego i 
			nadajemy mu numer DFS 5. Krawêd¼ 3 &#8211; 4 zostaje dopisana do 
			drzewa rozpinaj±cego.<p>Wierzcho³ek posiada jednego nieodwiedzonego 
			s±siada: 5.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_13.gif" width="143" height="196"></td>
			<td nowrap="">&nbsp;</td>
			<td>Odwiedzamy wierzcho³ek 5. Oznaczamy go jako odwiedzonego i 
			nadajemy mu numer DFS 6. Krawêd¼ 4 &#8211; 5 zostaje dopisana do 
			drzewa rozpinaj±cego.<p>Wierzcho³ek nr 5 nie posiada nieodwiedzonych 
			s±siadów. Wierzcho³ek nr 5 nie posiada synów, nie mo¿e byæ punktem 
			artykulacji.</p>
			<p>Wyliczamy parametr Low jako najmniejsz± warto¶æ z 6
			<span class="rem">(numer DFS wierzcho³ka)</span> i 4
			<span class="rem">(numer DFS wierzcho³ka 3, który ³±czy siê 
			krawêdzi± wtórn±)</span>.</p>
			<p>Low(5) = min (6,4) = 4.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_14.gif" width="143" height="197"></td>
			<td nowrap="">&nbsp;</td>
			<td>Wracamy do wierzcho³ka nr 4. Wszyscy s±siedzi s± odwiedzeni. 
			Wierzcho³ek nr 4 posiada syna 5, lecz parametr Low(5) jest mniejszy 
			od numeru DFS wierzcho³ka. Zatem wierzcho³ek nr 4 nie jest punktem 
			artykulacji.<p>Obliczamy parametr Low jako najmniejsz± warto¶æ z 5
			<span class="rem">(numer DFS wierzcho³ka)</span> i 4
			<span class="rem">(parametr Low jego syna 5)</span>.</p>
			<p>Low(4) = min (5,4) = 4.</p>
			<p>&nbsp;</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_15.gif" width="143" height="197"></td>
			<td nowrap="">&nbsp;</td>
			<td>Wracamy do wierzcho³ka nr 3.<p>Zauwa¿amy, i¿ parametr syna 
			Low(4) = 4 spe³nia kryterium punktu artykulacji <span class="rem">
			(jest wiêkszy lub równy numerowi DFS wierzcho³ka)</span>. Zatem 
			wierzcho³ek nr 3 jest punktem artykulacji.</p>
			<p>Wyznaczamy parametr Low(3) jako najmniejsz± warto¶æ z 4
			<span class="rem">(numer DFS wierzcho³ka)</span>, 4
			<span class="rem">(parametr Low(4) syna na drzewie rozpinaj±cym)</span> 
			i 6 <span class="rem">(numer DFS wierzcho³ka 5 po³±czonego krawêdzi± 
			wtórn±)</span>.</p>
			<p>Low(3) = min (4,4,6) = 4 </p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_16.gif" width="143" height="197"></td>
			<td nowrap="">&nbsp;</td>
			<td>Wracamy do wierzcho³ka 0. Wszyscy s±siedzi s± odwiedzeni. 
			Poniewa¿ wierzcho³ek 0 jest korzeniem drzewa rozpinaj±cego, to 
			sprawdzamy dla niego pierwsze kryterium. Posiada dwóch synów na 
			drzewie rozpinaj±cym, zatem jest punktem artykulacji
			<span class="rem">(parametru Low nawet nie musimy dla niego 
			obliczaæ, gdy¿ nie bêdzie on ju¿ dalej potrzebny)</span>.</td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p>
<h4><a name="A2"></a>Algorytm Tarjana wyszukiwania punktów artykulacji w grafie 
nieskierowanym</h4>
	<h5>Funkcja rekurencyjna DFSap(v,vf,graf,D,dv,L)</h5>
	<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table259" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>v</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>wierzcho³ek startowy, <i>v</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>vf</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>ojciec wierzcho³ka v na drzewie rozpinaj±cym w g³±b, <i>vf</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>D</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>tablica numerów DFS dla poszczególnych wierzcho³ków</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i><span lang="en-us">dv</span></i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>referencja do zmiennej zewnêtrznej przechowuj±cej numery wierzcho³ków. 
	Przy pierwszym wywo³aniu zmienna powinna zawieraæ 2. <i>dv</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista punktów artykulacji.</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
Warto¶æ parametru <i>Low</i> dla wierzcho³ka <i>v</i>. Je¶li zostanie znaleziony 
punkt artykulacji, to bêdzie on dopisany do listy <i>L</i>.</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table261" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>Low</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>warto¶æ parametru Low dla bie¿±cego wierzcho³ka, <i>Low</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>temp</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>chwilowo przechowuje wynik wywo³ania rekurencyjnego, <i>t</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap="">test</td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zawiera wynik testu na punkt artykulacji</td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table268">
    <tbody><tr>
      <td valign="top">K01:</td>
      <td nowrap="" valign="top"><i>D</i>[<i>v</i>] &#8592; <i>dv</i></td>
      <td class="c" valign="top">; numerujemy wierzcho³ek</td>
    </tr>
    <tr>
      <td valign="top">K02</td>
      <td nowrap="" valign="top"><i>Low</i> &#8592; <i>dv</i></td>
      <td class="c" valign="top">; wstêpna warto¶æ parametru </td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top"><i>dv</i> &#8592; <i>dv</i> + 1</td>
      <td class="c" valign="top">; kolejny wierzcho³ek bêdzie mia³ numer o 1 
		wiêkszy</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top"><i>test</i> &#8592; false</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top"><b>Dla</b> ka¿dego s±siada <i>u</i> wierzcho³ka <i>
		v</i>, <b>wykonuj</b> K06...K12</td>
      <td class="c" valign="top">; przegl±damy wszystkich s±siadów wierzcho³ka 
		bie¿±cego</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>u</i> = <i>vf</i>,
		<b>to nastêpny obieg pêtli</b> K05</td>
      <td class="c" valign="top">; pomijamy ojca</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>u</i>] 
		= 0, <b>to id¼ do</b> K10</td>
      <td class="c" valign="top">; s±siad nieodwiedzony?</td>
    </tr>
    <tr>
      <td valign="top">K08:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>u</i>] 
		&lt; <i>Low</i>, <b>to</b> <i>Low</i> &#8592; <i>D</i>[<i>u</i>]</td>
      <td class="c" valign="top">; odwiedzony, krawêd¼ wtórna. Modyfikujemy 
		parametr Low</td>
    </tr>
    <tr>
      <td valign="top">K09:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K10:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <i>temp</i> &#8592; DFSb(<i>u</i>,<i>v,graf</i>,<i>T</i>,<i>D</i>,<i>dv</i>,<i>L</i>)</td>
      <td class="c" valign="top">; rekurencyjne wywo³anie funkcji</td>
    </tr>
    <tr>
      <td valign="top">K11:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>temp</i> &lt; <i>
		Low</i>, <b>to</b> <i>Low</i> &#8592; <i>temp</i></td>
      <td class="c" valign="top">; modyfikujemy parametr Low</td>
    </tr>
    <tr>
      <td valign="top">K12:</td>
      <td nowrap="" valign="top"><b>&nbsp;&nbsp;&nbsp; Je¶li</b> <i>temp</i> &#8805; D[v] <b>to</b> 
		<i>test</i> &#8592; true</td>
      <td class="c" valign="top">; robimy test na punkt artykulacji</td>
    </tr>
    <tr>
      <td valign="top">K13:</td>
      <td nowrap="" valign="top"><b>Je¶li</b> <i>test</i> = true, <b>to </b>dodaj
		<i>v</i> do <i>L</i></td>
      <td class="c" valign="top">; je¶li va jest punktem artykulacji, to 
		dodajemy go do listy L</td>
    </tr>
    <tr>
      <td valign="top">K14:</td>
      <td nowrap="" valign="top"><b>Zakoñcz z wynikiem</b> <i>Low</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    </tbody></table>
  	</div>
	<h5>Algorytm g³ówny</h5>
	<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table265" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>n</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba wierzcho³ków w grafie, <i>n</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
<table id="table266" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista numerów wierzcho³ków, które s± punktami artykulacji</td>
  </tr>
  </tbody></table>
	</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table267" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>dv</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>przechowuje numery wierzcho³ków dla DFS, <i>dv</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>D</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>dynamiczna tablica dla numerów wierzcho³ków nadawanych przez DFS. 
	Elementy s± liczbami ca³kowitymi.</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>v,u</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>numery wierzcho³ków w grafie, <i>v,u</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>nc</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba synów na drzewie rozpinaj±cym dla korzenia, <i>nc</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table262">
    <tbody><tr>
      <td valign="top">K01:</td>
      <td nowrap="" valign="top">Twórz <i>n</i> elementow± tablicê <i>D</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K02:</td>
      <td nowrap="" valign="top">Zeruj tablicê <i>D</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top">Twórz pust± listê <i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top"><b>Dla</b> <i>v</i> = 0,1,...,<i>n</i>-1: <b>
		wykonuj</b> K05...K13</td>
      <td class="c" valign="top">; przechodzimy przez kolejne wierzcho³ki grafu</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>v</i>] 
		&gt; 0, <b>to nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">; szukamy nieodwiedzonego wierzcho³ka</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <i>dv</i> &#8592; 2</td>
      <td class="c" valign="top">; pocz±tek numeracji DFS dla synów</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <i>nc</i>&nbsp; &#8592; 0</td>
      <td class="c" valign="top">; liczba synów na drzewie rozpinaj±cym w g³±b</td>
    </tr>
    <tr>
      <td valign="top">K08:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <i>D</i>[<i>v</i>]&nbsp; &#8592; 
		1</td>
      <td class="c" valign="top">; korzeñ ma zawsze numer DFS równy 1</td>
    </tr>
    <tr>
      <td valign="top">K09:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Dla</b> ka¿dego s±siada <i>u</i> 
		wierzcho³ka <i>v</i> <b>wykonuj</b> K10...K12</td>
      <td class="c" valign="top">; przegl±damy s±siadów</td>
    </tr>
    <tr>
      <td valign="top">K10</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
		Je¶li</b> <i>D</i>[<i>u</i>] &gt; 0, <b>to nastêpny obieg pêtli</b> K09</td>
      <td class="c" valign="top">; szukamy nieodwiedzonego s±siada</td>
    </tr>
    <tr>
      <td valign="top">K11:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>nc</i> &#8592;
		<i>nc</i> + 1</td>
      <td class="c" valign="top">; znale¼li¶my syna, zwiêkszamy licznik synów</td>
    </tr>
    <tr>
      <td valign="top">K12:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DFSap(<i>u</i>,<i>v,graf</i>,<i>D</i>,<i>dv</i>,<i>L</i>)</td>
      <td class="c" valign="top">; wywo³ujemy przej¶cie DFS</td>
    </tr>
    <tr>
      <td valign="top">K13:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>nc</i> &gt; 1, <b>
		to</b> dodaj <i>v</i> do <i>L</i></td>
      <td class="c" valign="top">; korzeñ ma co najmniej dwóch synów - jest 
		punktem artykulacji</td>
    </tr>
    <tr>
      <td valign="top">K14:</td>
      <td nowrap="" valign="top"><b>Zakoñcz z wynikiem</b> <i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    </tbody></table>
  	</div>
	<p>&nbsp;</p>
<h4>Program</h4> <div class="sb1"><table border="0" cellpadding="8" style="border-collapse: collapse" id="table263">
    <tbody><tr>
      <td class="note"><b>Wa¿ne</b>:<br>
 <p class="bl1">Zanim uruchomisz program, przeczytaj <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td></tr>
  </tbody></table>
  <p>&nbsp;</p></div>
<div class="sb1">
	Program odczytuje <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0124.php#P1">definicjê</a> grafu 
	nieskierowanego, wyszukuje w nim wszystkie punkty artykulacji i wy¶wietla je w oknie 
	konsoli. Aby upro¶ciæ funkcjê rekurencyjn± DFSap(), wiêkszo¶æ jej parametrów 
	zosta³a zrealizowana jako zmienne globalne.<p>&nbsp;</p>
	<p>Przyk³adowe dane:</p>
	<table border="0" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td>
				<img border="0" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_02.gif" width="243" height="148"></td>
				<td><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
				<td>8 11<br>
				0 1 0 2 0 3 0 5<br>
				1 4 1 5<br>
				2 3<br>
				3 6 3 7<br>
				4 5<br>
				6 7</td>
			</tr>
		</tbody></table>
	<table border="1" id="table264" cellspacing="0" cellpadding="4" style="border-collapse: collapse" bordercolor="#808080">
		<tbody><tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Lazarus</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="pas"><pre><span class="c">// Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">// Data: 30.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//---------------------------------------------------------</span>

<span class="i">program</span> <span class="v">bridges</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa i listy punktów artykulacji</span>
<span class="i">type</span>
  <span class="v">PslistEl</span> = ^<span class="v">slistEl</span>;
  <span class="v">slistEl</span> =  <span class="i">record</span>
    <span class="v">next</span>  : <span class="v">PslistEl</span>;
    <span class="v">v</span>     : <span class="v">integer</span>;
  <span class="i">end</span>;

<span class="v">TList</span> = <span class="i">array</span> <span class="i">of</span> <span class="v">PslistEl</span>;

<span class="c">// Zmienne globalne</span>

<span class="i">var</span>
  <span class="v">n</span>,<span class="v">m</span>,<span class="v">dv</span> : <span class="v">integer</span>;           <span class="c">// Liczba wierzcho³ków, krawêdzi, numeracja</span>
  <span class="v">graf</span>   : <span class="v">TList</span>;             <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">D</span>      : <span class="i">array</span> <span class="i">of</span> <span class="v">integer</span>;  <span class="c">// Numery DFS</span>
  <span class="v">L</span>      : <span class="v">PslistEl</span>;          <span class="c">// Lista mostów</span>

<span class="c">// Funkcja rekurencyjna wyszukuj±ca punkty artykulacji</span>
<span class="c">// v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">// vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">// Reszta parametrów to zmienne globalne</span>
<span class="c">//----------------------------------------------------------</span>
<span class="i">function</span> <span class="v">DFSap</span>(<span class="v">v</span>,<span class="v">vf</span> : <span class="v">integer</span>) : <span class="v">integer</span>;
<span class="i">var</span>
  <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span> : <span class="v">integer</span>;
  <span class="v">test</span>       : <span class="v">boolean</span>;
  <span class="v">p</span>          : <span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="v">D</span>[<span class="v">v</span>] := <span class="v">dv</span>;                 <span class="c">// Numerujemy wierzcho³ek</span>
  <span class="v">Low</span>  := <span class="v">dv</span>;                 <span class="c">// Wstêpna warto¶æ parametru Low</span>
  <span class="v">inc</span>(<span class="v">dv</span>);                    <span class="c">// Nastêpny numer wierzcho³ka</span>
  <span class="v">test</span> := <span class="v">false</span>;
  <span class="v">p</span> := <span class="v">graf</span>[<span class="v">v</span>];               <span class="c">// Przegl±damy listê s±siadów</span>
  <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">u</span> := <span class="v">p</span>^.<span class="v">v</span>;                <span class="c">// u - numer wierzcho³ka s±siada</span>
    <span class="i">if</span> <span class="v">u</span> &lt;&gt; <span class="v">vf</span> <span class="i">then</span>           <span class="c">// u nie mo¿e byæ ojcem v</span>
    <span class="i">begin</span>
      <span class="i">if</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">then</span>        <span class="c">// Je¶li s±siad u nie by³ odwiedzany, to</span>
      <span class="i">begin</span>
        <span class="v">temp</span> := <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>);   <span class="c">// rekurencyjnie odwiedzamy go</span>
        <span class="i">if</span> <span class="v">temp</span> &lt; <span class="v">Low</span> <span class="i">then</span> <span class="v">Low</span> := <span class="v">temp</span>;
        <span class="i">if</span> <span class="v">temp</span> &gt;= <span class="v">D</span>[<span class="v">v</span>] <span class="i">then</span> <span class="v">test</span> := <span class="v">true</span>; <span class="c">// Test na punkt artykulacji</span>
      <span class="i">end</span>
      <span class="i">else</span> <span class="i">if</span> <span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span> <span class="i">then</span> <span class="v">Low</span> := <span class="v">D</span>[<span class="v">u</span>];
    <span class="i">end</span>;
    <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;             <span class="c">// Nastêpny wierzcho³ek na li¶cie</span>
  <span class="i">end</span>;

  <span class="c">// Wszyscy s±siedzi zostali odwiedzeni, sprawdzamy wynik testu</span>

  <span class="i">if</span> <span class="v">test</span> <span class="i">then</span>
  <span class="i">begin</span>
    <span class="v">new</span>(<span class="v">p</span>);                   <span class="c">// Mamy nowy punkt artykulacji</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">p</span>;
  <span class="i">end</span>;

  <span class="v">DFSap</span> := <span class="v">Low</span>;                <span class="c">// Wynik</span>
<span class="i">end</span>;

<span class="c">// **********************</span>
<span class="c">// *** Program g³ówny ***</span>
<span class="c">// **********************</span>

<span class="i">var</span>
  <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span>,<span class="v">nc</span> : <span class="v">integer</span>;        <span class="c">// Numery wierzcho³ków, licznik synów korzenia</span>
  <span class="v">p</span>,<span class="v">r</span>      : <span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="v">read</span>(<span class="v">n</span>,<span class="v">m</span>);                 <span class="c">// Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="v">n</span>);         <span class="c">// Tworzymy zmienne dynamiczne</span>
  <span class="v">SetLength</span>(<span class="v">D</span>,<span class="v">n</span>);
  <span class="v">L</span> := <span class="v">nil</span>;

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">graf</span>[<span class="v">i</span>] := <span class="v">nil</span>;
    <span class="v">D</span>[<span class="v">i</span>]    := <span class="n">0</span>;
  <span class="i">end</span>;

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">m</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">read</span>(<span class="v">v</span>,<span class="v">u</span>);               <span class="c">// Wierzcho³ki tworz±ce krawêd¼</span>
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// Tworzymy nowy element</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">u</span>;               <span class="c">// Numerujemy go jako w</span>
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">v</span>];      <span class="c">// Dodajemy go na pocz±tek listy graf[v]</span>
    <span class="v">graf</span>[<span class="v">v</span>] := <span class="v">p</span>;
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// To samo dla krawêdzi w drug± stronê</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">u</span>];
    <span class="v">graf</span>[<span class="v">u</span>] := <span class="v">p</span>;
  <span class="i">end</span>;

  <span class="c">// Szukamy punktów artykulacji</span>

  <span class="i">for</span> <span class="v">v</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
    <span class="i">if</span> <span class="v">D</span>[<span class="v">v</span>] = <span class="n">0</span> <span class="i">then</span>        <span class="c">// Szukamy nieodwiedzonego wierzcho³ka</span>
    <span class="i">begin</span>
      <span class="v">dv</span>   := <span class="n">2</span>;            <span class="c">// Numer DFS dla pierwszego syna</span>
      <span class="v">nc</span>   := <span class="n">0</span>;            <span class="c">// Zerujemy licznik synów</span>
      <span class="v">D</span>[<span class="v">v</span>] := <span class="n">1</span>;            <span class="c">// Korzeñ zawsze ma numer DFS 1</span>
      <span class="v">p</span> := <span class="v">graf</span>[<span class="v">v</span>];         <span class="c">// Przegl±damy s±siadów v</span>
      <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
      <span class="i">begin</span>
        <span class="v">u</span> := <span class="v">p</span>^.<span class="v">v</span>;          <span class="c">// Numer wierzcho³ka s±siedniego</span>
        <span class="i">if</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">then</span>    <span class="c">// Szukamy nieodwiedzonego s±siada</span>
        <span class="i">begin</span>
          <span class="v">inc</span>(<span class="v">nc</span>);          <span class="c">// Zwiêkszamy licznik synów</span>
          <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>);       <span class="c">// Szukamy punktów artykulacji w grafie</span>
        <span class="i">end</span>;
        <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;
      <span class="i">end</span>;
      <span class="i">if</span> <span class="v">nc</span> &gt; <span class="n">1</span> <span class="i">then</span>        <span class="c">// Czy korzeñ jest punktem artykulacji?</span>
      <span class="i">begin</span>
        <span class="v">new</span>(<span class="v">p</span>);             <span class="c">// Tak, dodajemy go do listy</span>
        <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
        <span class="v">p</span>^.<span class="v">next</span> := <span class="v">L</span>;
        <span class="v">L</span> := <span class="v">p</span>;
      <span class="i">end</span>;
    <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="c">// Wypisujemy znalezione punkty artykulacji</span>

  <span class="i">while</span> <span class="v">L</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">write</span>(<span class="v">L</span>^.<span class="v">v</span>,<span class="t">' '</span>);
    <span class="v">p</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">L</span>^.<span class="v">next</span>;
    <span class="v">dispose</span>(<span class="v">p</span>);
  <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="c">// Usuwamy struktury dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">D</span>,<span class="n">0</span>);

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">p</span> := <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">r</span> := <span class="v">p</span>;
      <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;
      <span class="v">dispose</span>(<span class="v">r</span>);
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="n">0</span>);
<span class="i">end</span>. </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Code::Blocks</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="cpp"><pre><span class="c">// Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">// Data: 30.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//---------------------------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa i listy punktów artykulacji</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>;
};

<span class="c">// Zmienne globalne</span>

<span class="i">int</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">dv</span>;                   <span class="c">// Liczba wierzcho³ków, krawêdzi, numeracja</span>
<span class="v">slistEl</span> ** <span class="v">graf</span>;              <span class="c">// Tablica list s±siedztwa</span>
<span class="i">int</span> *<span class="v">D</span>;                       <span class="c">// Numery DFS</span>
<span class="v">slistEl</span> * <span class="v">L</span>;                  <span class="c">// Lista mostów</span>

<span class="c">// Funkcja rekurencyjna wyszukuj±ca punkty artykulacji</span>
<span class="c">// v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">// vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">// Reszta parametrów to zmienne globalne</span>
<span class="c">//----------------------------------------------------------</span>
<span class="i">int</span> <span class="v">DFSap</span>(<span class="i">int</span> <span class="v">v</span>, <span class="i">int</span> <span class="v">vf</span>)
{
  <span class="i">int</span> <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span>;
  <span class="i">bool</span> <span class="v">test</span>;
  <span class="v">slistEl</span> * <span class="v">p</span>;

  <span class="v">D</span>[<span class="v">v</span>] = <span class="v">Low</span> = <span class="v">dv</span>++;

  <span class="v">test</span> = <span class="i">false</span>;

  <span class="i">for</span>(<span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]; <span class="v">p</span>; <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>) <span class="c">// Przegl±damy listê s±siadów</span>
  {
    <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;                 <span class="c">// u - numer wierzcho³ka s±siada</span>
    <span class="i">if</span>(<span class="v">u</span> != <span class="v">vf</span>)               <span class="c">// u nie mo¿e byæ ojcem v</span>
    {
      <span class="i">if</span>(!<span class="v">D</span>[<span class="v">u</span>])               <span class="c">// Je¶li s±siad u nie by³ odwiedzany, to</span>
      {
        <span class="v">temp</span> = <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>);    <span class="c">// rekurencyjnie odwiedzamy go</span>
        <span class="i">if</span>(<span class="v">temp</span> &lt; <span class="v">Low</span>) <span class="v">Low</span> = <span class="v">temp</span>;
        <span class="i">if</span>(<span class="v">temp</span> &gt;= <span class="v">D</span>[<span class="v">v</span>]) <span class="v">test</span> = <span class="i">true</span>; <span class="c">// Test na punkt artykulacji</span>
      }
      <span class="i">else</span> <span class="i">if</span>(<span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span>) <span class="v">Low</span> = <span class="v">D</span>[<span class="v">u</span>];
    }
  }

  <span class="c">// Wszyscy s±siedzi zostali odwiedzeni, sprawdzamy wynik testu</span>

  <span class="i">if</span>(<span class="v">test</span>)
  {
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;          <span class="c">// Mamy nowy punkt artykulacji</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">p</span>;
  }

  <span class="i">return</span> <span class="v">Low</span>;                <span class="c">// Wynik</span>
}

<span class="c">// **********************</span>
<span class="c">// *** Program g³ówny ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span>,<span class="v">nc</span>;              <span class="c">// Numery wierzcho³ków, licznik synów korzenia</span>
  <span class="v">slistEl</span> *<span class="v">p</span>,*<span class="v">r</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

  <span class="v">graf</span> = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>];  <span class="c">// Tworzymy zmienne dynamiczne</span>
  <span class="v">D</span> = <span class="i">new</span> <span class="i">int</span>[<span class="v">n</span>];
  <span class="v">L</span> = <span class="v">NULL</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">graf</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
    <span class="v">D</span>[<span class="v">i</span>]    = <span class="n">0</span>;
  }

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">u</span>;           <span class="c">// Wierzcho³ki tworz±ce krawêd¼</span>
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;         <span class="c">// Tworzymy nowy element</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>;                <span class="c">// Numerujemy go jako w</span>
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">v</span>];       <span class="c">// Dodajemy go na pocz±tek listy graf[v]</span>
    <span class="v">graf</span>[<span class="v">v</span>] = <span class="v">p</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;         <span class="c">// To samo dla krawêdzi w drug± stronê</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">u</span>];
    <span class="v">graf</span>[<span class="v">u</span>] = <span class="v">p</span>;
  }

  <span class="c">// Szukamy punktów artykulacji</span>

  <span class="i">for</span>(<span class="v">v</span> = <span class="n">0</span>; <span class="v">v</span> &lt; <span class="v">n</span>; <span class="v">v</span>++)
    <span class="i">if</span>(!<span class="v">D</span>[<span class="v">v</span>])               <span class="c">// Szukamy nieodwiedzonego wierzcho³ka</span>
    {
      <span class="v">dv</span>   = <span class="n">2</span>;             <span class="c">// Numer DFS dla pierwszego syna</span>
      <span class="v">nc</span>   = <span class="n">0</span>;             <span class="c">// Zerujemy licznik synów</span>
      <span class="v">D</span>[<span class="v">v</span>] = <span class="n">1</span>;             <span class="c">// Korzeñ zawsze ma numer DFS 1</span>
      <span class="i">for</span>(<span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]; <span class="v">p</span>; <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>) <span class="c">// Przegl±damy s±siadów v</span>
      {
        <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;           <span class="c">// Numer wierzcho³ka s±siedniego</span>
        <span class="i">if</span>(!<span class="v">D</span>[<span class="v">u</span>])           <span class="c">// Szukamy nieodwiedzonego s±siada</span>
        {
          <span class="v">nc</span>++;             <span class="c">// Zwiêkszamy licznik synów</span>
          <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>);       <span class="c">// Szukamy punktów artykulacji w grafie</span>
        }
      }

      <span class="i">if</span>(<span class="v">nc</span> &gt; <span class="n">1</span>)            <span class="c">// Czy korzeñ jest punktem artykulacji?</span>
      {
        <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;    <span class="c">// Tak, dodajemy go do listy</span>
        <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
        <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
        <span class="v">L</span> = <span class="v">p</span>;
      }
    }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Wypisujemy znalezione punkty artykulacji</span>

  <span class="i">while</span>(<span class="v">L</span>)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">L</span>-&gt;<span class="v">v</span> &lt;&lt; <span class="t">" "</span>;
    <span class="v">p</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> <span class="v">p</span>;
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Usuwamy struktury dynamiczne</span>

  <span class="i">delete</span> [] <span class="v">D</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">p</span> = <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">p</span>)
    {
      <span class="v">r</span> = <span class="v">p</span>;
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">r</span>;
    }
  }

  <span class="i">delete</span> <span class="v">graf</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Free Basic</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="bas"><pre><span class="c">' Wyszukiwanie punktów artykulacji w grafie nieskierowanym</span>
<span class="c">' Data: 30.12.2013</span>
<span class="c">' (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">'---------------------------------------------------------</span>

<span class="c">' Typy dla dynamicznej tablicy list s±siedztwa i listy punktów artykulacji</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Next</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="c">' Zmienne globalne</span>

<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">dv</span>        <span class="c">' Liczba wierzcho³ków, krawêdzi, numeracja</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">graf</span>  <span class="c">' Tablica list s±siedztwa</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">D</span>         <span class="c">' Numery DFS</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">L</span>         <span class="c">' Lista mostów</span>

<span class="c">' Funkcja rekurencyjna wyszukuj±ca punkty artykulacji</span>
<span class="c">' v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">' vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">' Reszta parametrów to zmienne globalne</span>
<span class="c">'----------------------------------------------------------</span>
<span class="i">Function</span> <span class="v">DFSap</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>, <span class="i">Byval</span> <span class="v">vf</span> <span class="i">As</span> <span class="i">Integer</span>) <span class="i">As</span> <span class="i">Integer</span>

  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span>,<span class="v">test</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>

  <span class="v">D</span>[<span class="v">v</span>] = <span class="v">dv</span>: <span class="v">Low</span> = <span class="v">dv</span>: <span class="v">dv</span> += <span class="n">1</span>

  <span class="v">test</span> = <span class="n">0</span>

  <span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]                 <span class="c">' Przegl±damy listê s±siadów</span>
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>                  <span class="c">' u - numer wierzcho³ka s±siada</span>
    <span class="i">If</span> <span class="v">u</span> &lt;&gt; <span class="v">vf</span> <span class="i">Then</span>           <span class="c">' u nie mo¿e byæ ojcem v</span>
      <span class="i">If</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">Then</span>        <span class="c">' Je¶li s±siad u nie by³ odwiedzany, to</span>
        <span class="v">temp</span> = <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>)     <span class="c">' rekurencyjnie odwiedzamy go</span>
        <span class="i">If</span> <span class="v">temp</span> &lt; <span class="v">Low</span> <span class="i">Then</span> <span class="v">Low</span> = <span class="v">temp</span>
        <span class="i">If</span> <span class="v">temp</span> &gt;= <span class="v">D</span>[<span class="v">v</span>] <span class="i">Then</span> <span class="v">test</span> = <span class="n">1</span> <span class="c">' Test na punkt artykulacji</span>
      <span class="i">Else</span>
        <span class="i">If</span>(<span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span>) <span class="i">Then</span> <span class="v">Low</span> = <span class="v">D</span>[<span class="v">u</span>]
      <span class="i">End</span> <span class="i">If</span>
    <span class="i">End</span> <span class="i">If</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
  <span class="i">Wend</span>

  <span class="c">' Wszyscy s±siedzi zostali odwiedzeni, sprawdzamy wynik testu</span>

  <span class="i">If</span> <span class="v">test</span> = <span class="n">1</span> <span class="i">Then</span>
    <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>           <span class="c">' Mamy nowy punkt artykulacji</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
    <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
    <span class="v">L</span> = <span class="v">p</span>
  <span class="i">End</span> <span class="i">If</span>

  <span class="i">Return</span> <span class="v">Low</span>                 <span class="c">' Wynik</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' **********************</span>
<span class="c">' *** Program g³ówny ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span>,<span class="v">nc</span>      <span class="c">' Numery wierzcho³ków, licznik synów korzenia</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>,<span class="v">r</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">n</span>,<span class="v">m</span>                 <span class="c">' Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

<span class="v">graf</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]   <span class="c">' Tworzymy zmienne dynamiczne</span>
<span class="v">D</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]
<span class="v">L</span>    = <span class="n">0</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">graf</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">D</span>[<span class="v">i</span>]    = <span class="n">0</span>
<span class="i">Next</span>

<span class="c">' Odczytujemy kolejne definicje krawêdzi</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">u</span>               <span class="c">' Wierzcho³ki tworz±ce krawêd¼</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' Tworzymy nowy element</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>                   <span class="c">' Numerujemy go jako u</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">v</span>]          <span class="c">' Dodajemy go na pocz±tek listy graf[v]</span>
  <span class="v">graf</span>[<span class="v">v</span>] = <span class="v">p</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' To samo dla krawêdzi w drug± stronê</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">u</span>]
  <span class="v">graf</span>[<span class="v">u</span>] = <span class="v">p</span>
<span class="i">Next</span>

<span class="i">Close</span> #<span class="n">1</span>

<span class="c">' Szukamy punktów artykulacji</span>

<span class="i">For</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="i">If</span> <span class="v">D</span>[<span class="v">v</span>] = <span class="n">0</span> <span class="i">Then</span>          <span class="c">' Szukamy nieodwiedzonego wierzcho³ka</span>
    <span class="v">dv</span>   = <span class="n">2</span>                <span class="c">' Numer DFS dla pierwszego syna</span>
    <span class="v">nc</span>   = <span class="n">0</span>                <span class="c">' Zerujemy licznik synów</span>
    <span class="v">D</span>[<span class="v">v</span>] = <span class="n">1</span>                <span class="c">' Korzeñ zawsze ma numer DFS 1</span>

    <span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]             <span class="c">' Przegl±damy s±siadów v</span>
    <span class="i">While</span> <span class="v">p</span>
      <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>              <span class="c">' Numer wierzcho³ka s±siedniego</span>
      <span class="i">If</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">Then</span>      <span class="c">' Szukamy nieodwiedzonego s±siada</span>
        <span class="v">nc</span> += <span class="n">1</span>             <span class="c">' Zwiêkszamy licznik synów</span>
        <span class="v">DFSap</span>(<span class="v">u</span>,<span class="v">v</span>)          <span class="c">' Szukamy punktów artykulacji w grafie</span>
      <span class="i">End</span> <span class="i">If</span>
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
    <span class="i">Wend</span>
    
    <span class="i">If</span> <span class="v">nc</span> &gt; <span class="n">1</span> <span class="i">Then</span>          <span class="c">' Czy korzeñ jest punktem artykulacji?</span>
      <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>       <span class="c">' Tak, dodajemy go do listy</span>
      <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
      <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
      <span class="v">L</span> = <span class="v">p</span>
    <span class="i">End</span> <span class="i">If</span> 
  <span class="i">End</span> <span class="i">If</span>
<span class="i">Next</span>

<span class="i">Print</span>

<span class="c">' Wypisujemy znalezione punkty artykulacji</span>

<span class="i">While</span> <span class="v">L</span>
  <span class="i">Print</span> <span class="v">L</span>-&gt;<span class="v">v</span>;
  <span class="v">p</span> = <span class="v">L</span>
  <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="i">Next</span>
  <span class="i">Delete</span> <span class="v">p</span>
<span class="i">Wend</span>

<span class="i">Print</span>

<span class="c">' Usuwamy dynamiczne struktury danych</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">p</span> = <span class="v">graf</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">r</span> = <span class="v">p</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">r</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">D</span>
<span class="i">Delete</span> [] <span class="v">graf</span>

<span class="i">End</span> </pre></pre></td>
		</tr>
		<tr>
			<td style="text-align: center" bgcolor="#F0F0F0" colspan="2"><b>Wynik</b></td>
		</tr>
		<tr>
			<td style="text-align: left" class="program">8 11<br>0 1 0 2 0 3 0 5<br>1 4 1 5<br>2 3<br>3 6 3 7<br>4 5<br>6 7<br>
			<br>0 3</td>
			<td style="text-align: center">
			<img src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/0130b_03.gif" width="243" height="148"></td>
		</tr>
	</tbody></table>
	</div>
	</div>
<p>&nbsp;</p></div><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none;"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><iframe frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:NaNpx;height:NaNpx;" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/saved_resource(4).html"></iframe></ins></ins></ins><iframe id="google_osd_static_frame_8828509123526" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/saved_resource(5).html"></iframe>
<div class="bl1">
  
<p>&nbsp;</p>
<hr color="#C0C0C0" size="1">
<div align="left">
  <table style="float: right; BORDER-COLLAPSE: collapse; padding-left:8px; padding-right:8px; padding-top:1px; padding-bottom:1px; cellPadding=" 4"="" border="0">
    <tbody><tr>
      <td><img src="./Algorytmy i Struktury Danych - Punkty artykulacji w grafie_files/i-lo_budynek.jpg"></td><td valign="top"><p align="center" style="text-align: center">&nbsp;&nbsp;&nbsp;I Liceum Ogólnokszta³c±ce&nbsp;&nbsp;&nbsp;<br><span class="small">im. Kazimierza Brodziñskiego<br> w Tarnowie</span><br><span class="small">&#169;2018 mgr Jerzy Wa³aszek</span></p></td>
    </tr>
  </tbody></table>
</div>
<span class="small">Dokument ten rozpowszechniany jest zgodnie z zasadami licencji<br>
<b>GNU Free Documentation License</b>.</span><p>Pytania proszê przesy³aæ na adres email: <a href="mailto:i-lo@eduinf.waw.pl">i-lo@eduinf.waw.pl</a>
</p>
<p><span class="small">W artyku³ach serwisu s± u¿ywane cookies. Je¶li nie chcesz ich otrzymywaæ,<br>
zablokuj je w swojej przegl±darce.<br>
<a target="_blank" href="https://policies.google.com/technologies/partner-sites?hl=pl">
Informacje dodatkowe</a></span></p>

</div>

<script type="text/javascript">pcba()</script>

</body></html>