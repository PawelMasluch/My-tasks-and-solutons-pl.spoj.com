
<!-- saved from url=(0050)https://eduinf.waw.pl/inf/alg/001_search/0130a.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">

<meta http-equiv="Content-Language" content="pl">
<title>Algorytmy i Struktury Danych - Mosty w grafie</title>
<meta name="description" content="Artyku³ opisuje ró¿ne algorytmy wyszukuj±ce informacje w zbiorach danych takich jak przedzia³y liczbowe, tablice, macierze, wektory, listy, drzewa, grafy, teksty itp.">
<meta name="keywords" content="wyszukiwanie, algorytm, programowanie, c++, pascal, basic, informatyka, liceum, matura, olimpiada, matematyka">
<link rel="stylesheet" type="text/css" href="./Algorytmy i Struktury Danych - Mosty w grafie_files/001.css">
<script src="./Algorytmy i Struktury Danych - Mosty w grafie_files/f.txt"></script><script src="./Algorytmy i Struktury Danych - Mosty w grafie_files/ca-pub-2048408300128807.js.pobrane"></script><script type="text/javascript" language="javascript" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/h.js.pobrane"></script>
<!--<base target="_top">--><base href="." target="_top">
        <script async="" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(1).txt"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2048408300128807",
    enable_page_level_ads: true
  });
</script>
<link rel="preload" href="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(2).txt" as="script"><script type="text/javascript" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(2).txt"></script><link rel="preload" href="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(3).txt" as="script"><script type="text/javascript" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(3).txt"></script></head>

<body><table border="0" width="100%" cellpadding="0" style="border-collapse: collapse">
  <tbody><tr>
    <td width="164" style="text-align: left" valign="top" class="menu_l"><a href="http://www.i-lo.tarnow.pl/"><img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/i-lo_logo.gif" width="164" height="170" style="margin-top: 12px" alt="Do strony g³ównej I LO w Tarnowie"></a></td>
    <td style="text-align: center" valign="top" class="menu_m" nowrap="">
    <a class="exit" href="https://eduinf.waw.pl/inf/index.php"><span>Wyj¶cie </span></a><a class="cont" href="https://eduinf.waw.pl/inf/alg/001_search/index.php"><span>Spis tre¶ci </span></a><a class="prev" href="https://eduinf.waw.pl/inf/alg/001_search/0130.php"><span>Poprzedni </span></a><a class="next" href="https://eduinf.waw.pl/inf/alg/001_search/0130b.php"><span>Nastêpny </span></a>
<p><img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_title.jpg" width="511" height="195" alt="tytu³"></p>
    <span class="small">Prezentowane materia³y s± przeznaczone dla uczniów szkó³ ponadgimnazjalnych</span>.<br>
    Autor artyku³u: mgr Jerzy Wa³aszek,&nbsp; wersja 2.0</td>
    <td style="padding:8px; text-align: center" valign="top" class="menu_r" nowrap="" width="200">
    <p class="small" style="line-height: 100%; margin-bottom: 0">&nbsp;&#169;2014 mgr Jerzy Wa³aszek<br>
    I LO w Tarnowie</p>
    <p><img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_logo.gif" width="134" height="102" alt="logo"></p>
    </td>
  </tr>
  <tr>
    <td style="text-align: center" colspan="3" height="100">
<script async="" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/f(1).txt"></script>
<!-- normal_page -->
<ins class="adsbygoogle" style="display: block; height: 90px;" data-ad-client="ca-pub-2048408300128807" data-ad-slot="9328341371" data-ad-format="auto" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:1200px;background-color:transparent;"><iframe width="1200" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:1200px;height:90px;" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/saved_resource.html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</td>
  </tr>
  </tbody></table>
<h1 class="sb1">Znajdowanie mostów w grafie</h1>
<hr color="#336699" size="1">
<table border="0" cellspacing="0" cellpadding="4" style="border-collapse: collapse" class="sb1" id="table248">
	<tbody><tr>
		<td bgcolor="#CCCCCC"><b>Tematy pokrewne</b></td>
<td bgcolor="#CCCCCC">&nbsp;</td>
<td bgcolor="#CCCCCC"><b>Podrozdzia³y</b></td>
</tr>
	<tr>
		<td valign="top"><b><a href="https://eduinf.waw.pl/inf/alg/001_search/0122.php">Grafy</a></b><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0123.php">Podstawowe pojêcia dotycz±ce grafów</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0124.php">Reprezentacja grafów w komputerze</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0125.php">Przechodzenie grafów w g³±b &#8211; DFS</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126.php">Przechodzenie grafów wszerz &#8211; BFS</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126a.php">Transpozycja grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126b.php">Kwadrat grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126c.php">Graf krawêdziowy</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0126d.php">Stopieñ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0127.php">Znajdowanie ¶cie¿ki w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0128.php">Znajdowanie drogi w labiryncie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0128a.php">Spójno¶æ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129.php">Znajdowanie spójnych sk³adowych w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129a.php">Znajdowanie silnie spójnych 
					sk³adowych w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130.php">Drzewa rozpinaj±ce grafu</a><br>
		<font color="#FF0000"><b>Znajdowanie mostów w grafie</b></font><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130b.php">Znajdowanie punktów artykulacji w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0131.php">Grafy dwudzielne</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0131a.php">Kojarzenie ma³¿eñstw</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0132.php">Cykliczno¶æ grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0133.php">Znajdowanie cykli w grafie</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0134.php">Istnienie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0135.php">Znajdowanie cyklu lub ¶cie¿ki Eulera</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0136.php">Znajdowanie cyklu lub ¶cie¿ki 
					Hamiltona</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0137.php">Sortowanie topologiczne grafu 
					skierowanego</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138.php">Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Dijkstry</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138a.php">Najkrótsza ¶cie¿ka w grafie wa¿onym &#8211; 
					algorytm Bellmana-Forda</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0138b.php">Najkrótsze ¶cie¿ki pomiêdzy 
					wszystkimi parami wierzcho³ków w grafie wa¿onym</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0139.php">Problem chiñskiego listonosza</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0140.php">Problem komiwoja¿era</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0141.php">Minimalne drzewo rozpinaj±ce</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0142.php">Kolorowanie grafu</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0143.php">Znajdowanie klik w grafie</a></td>
		<td valign="top">&nbsp;</td>
		<td valign="top"><a href="https://eduinf.waw.pl/inf/alg/001_search/0130a.php#P1">Rozwi±zanie nr 1</a><br>
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0130a.php#P2">Rozwi±zanie nr 2</a></td>
	</tr>
</tbody></table>
<div class="bl2">
  <p class="mlink">&nbsp;</p></div>
<div class="bl1">
<h3>Problem</h3>
<p class="bl2">Dla danego grafu nieskierowanego wyznaczyæ wszystkie mosty.</p>
<div class="sb1">
	<p><br>
	</p>
	<p style="text-align: center">
	<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_14.gif" width="427" height="148"></p>
	<p style="text-align: center">&nbsp;</p>
	<p><b>Mostem</b> <span class="rem">(ang. bridge)</span> nazywamy krawêd¼ grafu, 
	której usuniêcie zwiêksza liczbê spójnych sk³adowych. Na powy¿szym rysunku 
	mostem jest krawêd¼ 0 &#8211; 1.</p>
	<p>&nbsp;</p>
</div>
<h3><a name="P1"></a>Rozwi±zanie nr 1
</h3>
<div class="sb1">
	<p>&nbsp;</p>
	<p>Naiwny sposób rozwi±zania tego problemu jest nastêpuj±cy:</p>
	<p>&nbsp;</p><div class="bl1">Obliczamy wstêpnie liczbê spójnych sk³adowych 
		w grafie <span class="rem">(mo¿emy tutaj wykorzystaæ algorytm opisany w
		<a href="https://eduinf.waw.pl/inf/alg/001_search/0129.php#A">rozdziale o spójnych sk³adowych</a>)</span> i zapamiêtujemy 
		j±. Nastêpnie wybieramy kolejne krawêdzie grafu. Wybran± krawêd¼ usuwamy 
		z grafu i ponownie wyznaczamy liczbê spójnych sk³adowych. Je¶li bêdzie 
		wiêksza od zapamiêtanej, to usuniêta krawêd¼ jest mostem. W takim 
		przypadku krawêd¼ tê zapamiêtujemy, wstawiamy z powrotem do grafu i 
		przechodzimy do nastêpnej krawêdzi. Gdy algorytm zakoñczy swoje 
		dzia³anie, otrzymamy listê krawêdzi, które s± mostami.</div>
	<p>&nbsp;</p>
<h4><a name="A1"></a>Algorytm naiwny wyszukiwania mostów w grafie nieskierowanym</h4>
<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table252" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>n</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba wierzcho³ków w grafie, <i>n</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
<table id="table258" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista par wierzcho³ków, które tworz± krawêdzie-mosty.</td>
  </tr>
  </tbody></table>
	</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table254" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap="">ccn(<i>n</i>,<i>graf</i>)</td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>funkcja zwracaj±ca liczbê spójnych sk³adowych w grafie</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>nc</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba spójnych sk³adowych grafu,&nbsp; <i>nc</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>v</i>,<i>u</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>numery wierzcho³ków grafu,&nbsp; <i>v,u</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table255">
    <tbody><tr>
      <td valign="top">K01:</td>
      <td nowrap="" valign="top">Utwórz pust± listê <i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K02:</td>
      <td nowrap="" valign="top"><i>nc</i> &#8592; ccn(<i>n</i>,<i>graf</i>)</td>
      <td class="c" valign="top">; zapamiêtujemy liczbê spójnych sk³adowych</td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top"><b>Dla</b> <i>v</i> = 0,1,...,<i>n</i>-1, <b>
		wykonuj</b> K04...K08</td>
      <td class="c" valign="top">; przechodzimy przez kolejne wierzcho³ki grafu</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Dla</b> ka¿dego s±siada <i>u</i> 
		wierzcho³ka <i>v</i> <b>wykonuj</b> K05...K08</td>
      <td class="c" valign="top">; przechodzimy przez wszystkich s±siadów 
		wierzcho³ka v</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
		Je¶li</b> <i>u</i> &#8804; <i>v</i>, <b>to nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">; ka¿d± krawêd¼ wybieramy jeden raz</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usuñ 
		krawêd¼ <i>v-u</i> z <i>grafu</i></td>
      <td class="c" valign="top">; wybran± krawêd¼ usuwamy</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
		Je¶li</b> ccn(<i>n</i>,<i>graf</i>) &gt; <i>nc</i>, <b>to</b> dodaj <i>v-u</i> 
		do <i>L</i></td>
      <td class="c" valign="top">; je¶li krawêd¼ jest mostem, to zapamiêtujemy 
		j± w L</td>
    </tr>
    <tr>
      <td valign="top">K08:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dodaj 
		krawêd¼ <i>v-u</i> do <i>grafu</i></td>
      <td class="c" valign="top">; odtwarzamy krawêd¼</td>
    </tr>
    <tr>
      <td valign="top">K09:</td>
      <td nowrap="" valign="top"><b>Zakoñcz</b></td>
      <td class="c" valign="top">; mosty w L</td>
    </tr>
    </tbody></table>
  <p>&nbsp;</p></div>
<h4>Program</h4> <div class="sb1"><table border="0" cellpadding="8" style="border-collapse: collapse">
    <tbody><tr>
      <td class="note"><b>Wa¿ne</b>:<br>
 <p class="bl1">Zanim uruchomisz program, przeczytaj <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td></tr>
  </tbody></table>
  <p>&nbsp;</p>
</div><div class="sb1">
	Program odczytuje <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0124.php#P1">definicjê</a> grafu 
	nieskierowanego, wyszukuje w nim wszystkie mosty i wy¶wietla je w oknie 
	konsoli. Poniewa¿ usuwanie krawêdzi mo¿e byæ nieco k³opotliwe, 
	zastosowali¶my tu nieco inn± metodê. Otó¿ wykorzystujemy dodatkow± tablicê 
	logiczn± <i>VU</i>, której elementy odzwierciedlaj± wierzcho³ki. Je¶li dla 
	danej krawêdzi <i>v-u</i> oba elementy <i>VU</i>[<i>v</i>] i <i>VU</i>[<i>u</i>] 
	maj± warto¶æ false, to krawêd¼ <i>v-u</i> jest usuniêta z grafu. Tablica <i>
	VU</i> jest dodatkowym parametrem funkcji ccn().<p>&nbsp;</p>
	<p>Przyk³adowe dane <span class="rem">(spójne sk³adowe 
	zosta³y pokolorowane w celach testowych)</span>:</p>
	<table border="0" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td>
				<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0129_03.gif" width="382" height="354"></td>
				<td><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
				<td>17 17<br>
				0 1 0 2 0 3<br>
				1 2 1 14<br>
				4 11 4 12<br>
				5 6 5 9<br>
				6 7 6 8<br>
				10 15<br>
				11 15<br>
				12 15<br>
				13 14 13 16<br>
				14 16</td>
			</tr>
		</tbody></table>
	<p>&nbsp;</p>
	<table border="1" id="table257" cellspacing="0" cellpadding="4" style="border-collapse: collapse" bordercolor="#808080">
		<tbody><tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Lazarus</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre>// Wyszukiwanie mostów w grafie nieskierowanym
// Data: 27.12.2013
// (C)2013 mgr Jerzy Wa³aszek
//--------------------------------------------

program bridges;

// Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy mostów
type
  PslistEl = ^slistEl;
  slistEl =  record
    next  : PslistEl;
    v     : integer;
  end;

TList = array of PslistEl;

// Definicja typu obiektowego stack
//---------------------------------
stack = object
  private
    S : PslistEl;  // lista przechowuj±ca stos

  public
    constructor init;
    destructor destroy;
    function   empty : boolean;
    function   top : integer;
    procedure  push(v : integer);
    procedure  pop;
end;

// Konstruktor
//------------
constructor stack.init;
begin
  S := nil;
end;

// Destruktor
//-----------

destructor stack.destroy;
begin
  while S &lt;&gt; nil do pop;
end;

// Sprawdza, czy stos jest pusty
//------------------------------
function stack.empty : boolean;
begin
  if S = nil then empty := true else empty := false;
end;

// Zwraca liczbê ze szczytu stosu
//----------------------------------
function stack.top : integer;
begin
  top := S^.v;
end;

// Umieszcza dane na stosie
//-------------------------
procedure stack.push(v : integer);
var
  e : PslistEl;
begin
  new(e);
  e^.v := v;
  e^.next := S;
  S := e;
end;

// Usuwa dane ze stosu
//--------------------
procedure stack.pop;
var
  e :PslistEl;
begin
  if S &lt;&gt; NIL then
  begin
    e := S;
    S := S^.next;
    dispose(e);
  end;
end;

// Funkcja oblicza liczbê spójnych sk³adowych w grafie
// n    - liczba wierzcho³ków w grafie
// graf - tablica list s±siedztwa
// VU   - tablica dostêpno¶ci krawêdzi grafu
//----------------------------------------------------
function ccn(n : integer; var graf : TList; VU : array of boolean) : integer;
var
  C        : array of integer;
  S        : stack;
  cc,i,v,u : integer;
  p        : PslistEl;

begin
  S.init;                    // Tworzymy pusty stos
  SetLength(C,n);            // Tworzymy tablicê spójnych sk³adowych
  for i := 0 to n - 1 do
    C[i] := 0;               // Zerujemy tablicê spójnych sk³adowych

  cc := 0;                   // Zerujemy licznik spójnych sk³adowych

  for i := 0 to n-1 do
    if C[i] = 0 then         // Szukamy nieodwiedzonego jeszcze wierzcho³ka
    begin
      inc(cc);               // Zwiêkszamy licznik sk³adowych
      S.push(i);             // Na stosie umieszczamy numer bie¿±cego wierzcho³ka
      C[i] := cc;            // Wierzcho³ek numerujemy i oznaczamy jako odwiedzony
      while not S.empty do   // Przechodzimy graf algorytmem DFS
      begin
        v := S.top;          // Pobieramy wierzcho³ek
        S.pop;               // Usuwamy go ze stosu
        p := graf[v];        // Przegl±damy s±siadów wierzcho³ka v
        while p &lt;&gt; nil do
        begin
          u := p^.v;         // Numer s±siada do u
          if (VU[v] or VU[u]) and (C[u] = 0) then
          begin
            S.push(u);       // Na stos id± s±siedzi nieodwiedzeni
            C[u] := cc;      // i ponumerowani
          end;
          p := p^.next;
        end;
      end;
    end;
  SetLength(C,0);           // Usuwamy tablicê C
  S.destroy;                // Usuwamy stos
  ccn := cc;                // Zwracamy wynik
end;

// **********************
// *** Program g³ówny ***
// **********************

var
  n,m      : integer;       // Liczba wierzcho³ków i krawêdzi
  A        : TList;         // Tablica list s±siedztwa
  nc,i,v,u : integer;
  L,p,r    : PslistEl;
  VU       : array of boolean;

begin
  read(n,m);                 // Odczytujemy liczbê wierzcho³ków i krawêdzi

  SetLength(A,n);            // Tworzymy tablice dynamiczne
  SetLength(VU,n);

  for i := 0 to n - 1 do
  begin
    A[i]  := nil;
    VU[i] := true;
  end;

  // Odczytujemy kolejne definicje krawêdzi

  for i := 0 to m - 1 do
  begin
    read(v,u);               // Wierzcho³ki tworz±ce krawêd¼
    new(p);                  // Tworzymy nowy element
    p^.v := u;               // Numerujemy go jako w
    p^.next := A[v];         // Dodajemy go na pocz±tek listy A[v]
    A[v] := p;
    new(p);                  // To samo dla krawêdzi w drug± stronê
    p^.v := v;
    p^.next := A[u];
    A[u] := p;
  end;

  // Algorytm znajdowania mostów

  L := nil;                  // Pusta lista mostów

  nc := ccn(n,A,VU);         // Zapamiêtujemy liczbê spójnych sk³adowych

  for v := 0 to n - 1 do     // Przechodzimy przez kolejne wierzcho³ki grafu
  begin
    p := A[v];               // Przegl±damy listê s±siedztwa wierzcho³ka v
    while p &lt;&gt; nil do
    begin
      u := p^.v;             // u - numer wierzcho³ka s±siedniego w grafie
      if u &gt; v then          // Interesuj± nas tylko krawêdzie w jedn± stronê
      begin
        VU[v] := false;      // Zaznaczamy krawêd¼ v-u jako usuniêt±
        VU[u] := false;
        if ccn(n,A,VU) &gt; nc then
        begin
          new(r);            // Znaleziony most dodajemy do listy L
          r^.v := u;
          r^.next := L;
          L := r;
          new(r);
          r^.v := v;
          r^.next := L;
          L := r;
        end;
        VU[v] := true;      // Kasujemy zaznaczenie krawêdzi jako usuniêtej
        VU[u] := true;
      end;
      p := p^.next;
    end;
  end;

  writeln;

  // Wypisujemy znalezione mosty, jednocze¶nie usuwaj±c listê L

  v := 0;

  while L &lt;&gt; nil do
  begin
    write(L^.v,' ');
    v := (v + 1) mod 2;
    if v = 0 then writeln;
    p := L;
    L := L^.next;
    dispose(p);
  end;

  // Usuwamy pozosta³e struktury dynamiczne

  for i := 0 to n - 1 do
  begin
    p := A[i];
    while p &lt;&gt; nil do
    begin
      r := p;
      p := p^.next;
      dispose(r);
    end;
  end;

  SetLength(A,0);
  SetLength(VU,0);
end.</pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Code::Blocks</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="cpp"><pre><span class="c">// Wyszukiwanie mostów w grafie nieskierowanym</span>
<span class="c">// Data: 27.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//--------------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy mostów</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>;
};

<span class="i">class</span> <span class="v">stack</span>
{
  <span class="i">private</span>:
    <span class="v">slistEl</span> * <span class="v">S</span>;   <span class="c">// lista przechowuj±ca stos</span>

  <span class="i">public</span>:
    <span class="v">stack</span>();       <span class="c">// konstruktor</span>
    ~<span class="v">stack</span>();      <span class="c">// destruktor</span>
    <span class="i">bool</span> <span class="v">empty</span>(<span class="i">void</span>);
    <span class="i">int</span>  <span class="v">top</span>(<span class="i">void</span>);
    <span class="i">void</span> <span class="v">push</span>(<span class="i">int</span> <span class="v">v</span>);
    <span class="i">void</span> <span class="v">pop</span>(<span class="i">void</span>);
};

<span class="c">//---------------------</span>
<span class="c">// Metody obiektu stack</span>
<span class="c">//---------------------</span>

<span class="c">// Konstruktor</span>
<span class="c">//------------</span>
<span class="v">stack</span>::<span class="v">stack</span>()
{
  <span class="v">S</span> = <span class="v">NULL</span>;
}

<span class="c">// Destruktor - zwalnia tablicê dynamiczn±</span>
<span class="c">//----------------------------------------</span>
<span class="v">stack</span>::~<span class="v">stack</span>()
{
  <span class="i">while</span>(<span class="v">S</span>) <span class="v">pop</span>();
}

<span class="c">// Sprawdza, czy stos jest pusty</span>
<span class="c">//------------------------------</span>
<span class="i">bool</span> <span class="v">stack</span>::<span class="v">empty</span>(<span class="i">void</span>)
{
  <span class="i">return</span> !<span class="v">S</span>;
}

<span class="c">// Zwraca szczyt stosu</span>
<span class="c">//--------------------</span>
<span class="i">int</span> <span class="v">stack</span>::<span class="v">top</span>(<span class="i">void</span>)
{
  <span class="i">return</span> <span class="v">S</span>-&gt;<span class="v">v</span>;
}

<span class="c">// Zapisuje na stos</span>
<span class="c">//-----------------</span>
<span class="i">void</span> <span class="v">stack</span>::<span class="v">push</span>(<span class="i">int</span> <span class="v">v</span>)
{
  <span class="v">slistEl</span> * <span class="v">e</span> = <span class="i">new</span> <span class="v">slistEl</span>;
  <span class="v">e</span>-&gt;<span class="v">v</span>    = <span class="v">v</span>;
  <span class="v">e</span>-&gt;<span class="v">next</span> = <span class="v">S</span>;
  <span class="v">S</span> = <span class="v">e</span>;
}

<span class="c">// Usuwa ze stosu</span>
<span class="c">//---------------</span>
<span class="i">void</span> <span class="v">stack</span>::<span class="v">pop</span>(<span class="i">void</span>)
{
  <span class="i">if</span>(<span class="v">S</span>)
  {
    <span class="v">slistEl</span> * <span class="v">e</span> = <span class="v">S</span>;
    <span class="v">S</span> = <span class="v">S</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> <span class="v">e</span>;
  }
}

<span class="c">// Funkcja oblicza liczbê spójnych sk³adowych w grafie</span>
<span class="c">// n    - liczba wierzcho³ków w grafie</span>
<span class="c">// graf - tablica list s±siedztwa</span>
<span class="c">// VU   - tablica dostêpno¶ci krawêdzi grafu</span>
<span class="c">//----------------------------------------------------</span>
<span class="i">int</span> <span class="v">ccn</span>(<span class="i">int</span> <span class="v">n</span>, <span class="v">slistEl</span> ** <span class="v">graf</span>, <span class="i">bool</span> * <span class="v">VU</span>)
{
  <span class="i">int</span> * <span class="v">C</span>,<span class="v">cc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>;
  <span class="v">stack</span> <span class="v">S</span>;
  <span class="v">slistEl</span> * <span class="v">p</span>;

  <span class="v">C</span> = <span class="i">new</span> <span class="i">int</span>[<span class="v">n</span>];            <span class="c">// Tworzymy tablicê spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++) <span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>; <span class="c">// Zerujemy tablicê spójnych sk³adowych</span>

  <span class="v">cc</span> = <span class="n">0</span>;                    <span class="c">// Zerujemy licznik spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
    <span class="i">if</span>(!<span class="v">C</span>[<span class="v">i</span>])                <span class="c">// Szukamy nieodwiedzonego jeszcze wierzcho³ka</span>
    {
      <span class="v">cc</span>++;                  <span class="c">// Zwiêkszamy licznik sk³adowych</span>
      <span class="v">S</span>.<span class="v">push</span>(<span class="v">i</span>);             <span class="c">// Na stosie umieszczamy numer bie¿±cego wêz³a</span>
      <span class="v">C</span>[<span class="v">i</span>] = <span class="v">cc</span>;             <span class="c">// Wierzcho³ek numerujemy i oznaczamy jako odwiedzony</span>
      <span class="i">while</span>(!<span class="v">S</span>.<span class="v">empty</span>())      <span class="c">// Przechodzimy graf algorytmem DFS</span>
      {
        <span class="v">v</span> = <span class="v">S</span>.<span class="v">top</span>();         <span class="c">// Pobieramy wierzcho³ek</span>
        <span class="v">S</span>.<span class="v">pop</span>();             <span class="c">// Usuwamy go ze stosu</span>
        <span class="i">for</span>(<span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]; <span class="v">p</span>; <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>) <span class="c">// Przegl±damy s±siadów wierzcho³ka v</span>
        {
          <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;
          <span class="i">if</span>((<span class="v">VU</span>[<span class="v">v</span>] || <span class="v">VU</span>[<span class="v">u</span>]) &amp;&amp; !<span class="v">C</span>[<span class="v">u</span>])
          {
            <span class="v">S</span>.<span class="v">push</span>(<span class="v">p</span>-&gt;<span class="v">v</span>);   <span class="c">// Na stos id± s±siedzi nieodwiedzeni</span>
            <span class="v">C</span>[<span class="v">u</span>] = <span class="v">cc</span>;      <span class="c">// i ponumerowani</span>
          }
        }
      }
    }

  <span class="i">delete</span> [] <span class="v">C</span>;               <span class="c">// Usuwamy tablicê C</span>
  <span class="i">return</span> <span class="v">cc</span>;                 <span class="c">// Zwracamy wynik</span>
}

<span class="c">// **********************</span>
<span class="c">// *** PROGRAM G£ÓWNY ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">n</span>,<span class="v">m</span>;                   <span class="c">// Liczba wierzcho³ków i krawêdzi</span>
  <span class="v">slistEl</span> ** <span class="v">A</span>;              <span class="c">// Tablica list s±siedztwa</span>
  <span class="i">int</span> <span class="v">nc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>;
  <span class="v">slistEl</span> * <span class="v">L</span>,* <span class="v">p</span>,* <span class="v">r</span>;
  <span class="i">bool</span> * <span class="v">VU</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Czytamy liczbê wierzcho³ków i krawêdzi</span>

  <span class="c">// Tworzymy zmienne dynamiczne</span>

  <span class="v">VU</span> = <span class="i">new</span> <span class="i">bool</span>[<span class="v">n</span>];          <span class="c">// Krawêdzie aktywne</span>
  <span class="v">A</span>  = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>];    <span class="c">// Tablica list s±siedztwa</span>

  <span class="c">// Tablicê wype³niamy pustymi listami</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">A</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
    <span class="v">VU</span>[<span class="v">i</span>] = <span class="i">true</span>;
  }

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">u</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">A</span>[<span class="v">v</span>];
    <span class="v">A</span>[<span class="v">v</span>] = <span class="v">p</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">A</span>[<span class="v">u</span>];
    <span class="v">A</span>[<span class="v">u</span>] = <span class="v">p</span>;
  }

  <span class="c">// Algorytm znajdowania mostów</span>

  <span class="v">L</span> = <span class="v">NULL</span>;                  <span class="c">// Pusta lista mostów</span>

  <span class="v">nc</span> = <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>);          <span class="c">// Zapamiêtujemy liczbê spójnych sk³adowych</span>

  <span class="i">for</span>(<span class="v">v</span> = <span class="n">0</span>; <span class="v">v</span> &lt; <span class="v">n</span>; <span class="v">v</span>++)     <span class="c">// Przechodzimy przez kolejne wierzcho³ki grafu</span>
  {
    <span class="v">p</span> = <span class="v">A</span>[<span class="v">v</span>];                <span class="c">// Przegl±damy listê s±siedztwa wierzcho³ka v</span>
    <span class="i">while</span>(<span class="v">p</span>)
    {
      <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;              <span class="c">// u - numer wierzcho³ka s±siedniego w grafie</span>
      <span class="i">if</span>(<span class="v">u</span> &gt; <span class="v">v</span>)              <span class="c">// Interesuj± nas tylko krawêdzie w jedn± stronê</span>
      {
        <span class="v">VU</span>[<span class="v">v</span>] = <span class="v">VU</span>[<span class="v">u</span>] = <span class="i">false</span>; <span class="c">// Zaznaczamy krawêd¼ v-u jako usuniêt±</span>
        <span class="i">if</span>(<span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>) &gt; <span class="v">nc</span>)
        {
          <span class="v">r</span> = <span class="i">new</span> <span class="v">slistEl</span>;   <span class="c">// Znaleziony most dodajemy do listy L</span>
          <span class="v">r</span>-&gt;<span class="v">v</span> = <span class="v">u</span>;
          <span class="v">r</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
          <span class="v">L</span> = <span class="v">r</span>;
          <span class="v">r</span> = <span class="i">new</span> <span class="v">slistEl</span>;
          <span class="v">r</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
          <span class="v">r</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
          <span class="v">L</span> = <span class="v">r</span>;
        }
        <span class="v">VU</span>[<span class="v">v</span>] = <span class="v">VU</span>[<span class="v">u</span>] = <span class="i">true</span>; <span class="c">// Kasujemy zaznaczenie krawêdzi jako usuniêtej</span>
      }
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>;
    }
  }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Wypisujemy znalezione mosty, jednocze¶nie usuwaj±c listê L</span>

  <span class="v">v</span> = <span class="n">0</span>;

  <span class="i">while</span>(<span class="v">L</span>)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">L</span>-&gt;<span class="v">v</span> &lt;&lt; <span class="t">" "</span>;
    <span class="v">v</span> ^= <span class="n">1</span>;
    <span class="i">if</span>(!<span class="v">v</span>) <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;
    <span class="v">p</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> [] <span class="v">p</span>;
  }

  <span class="c">// Usuwamy dynamiczne struktury danych</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">p</span> = <span class="v">A</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">p</span>)
    {
      <span class="v">r</span> = <span class="v">p</span>;
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">r</span>;
    }
  }

  <span class="i">delete</span> [] <span class="v">A</span>;
  <span class="i">delete</span> [] <span class="v">VU</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Free Basic</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="bas"><pre><span class="c">' Wyszukiwanie mostów w grafie nieskierowanym</span>
<span class="c">' Data: 27.12.2013</span>
<span class="c">' (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">'--------------------------------------------</span>

<span class="c">' Typy dla dynamicznej tablicy list s±siedztwa, stosu i listy mostów</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Next</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="i">Type</span> <span class="v">stack</span>
  <span class="i">Private</span>:
    <span class="v">S</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>  <span class="c">' lista zawieraj±ca stos</span>
  <span class="i">Public</span>:
    <span class="i">Declare</span> <span class="i">Constructor</span>()
    <span class="i">Declare</span> <span class="i">Destructor</span>()
    <span class="i">Declare</span> <span class="i">Function</span> <span class="v">empty</span>() <span class="i">As</span> <span class="i">Integer</span>
    <span class="i">Declare</span> <span class="i">Function</span> <span class="v">top</span> <span class="i">As</span> <span class="i">Integer</span>
    <span class="i">Declare</span> <span class="i">Sub</span> <span class="v">push</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>)
    <span class="i">Declare</span> <span class="i">Sub</span> <span class="v">pop</span>()
<span class="i">End</span> <span class="i">Type</span>

<span class="c">'---------------------</span>
<span class="c">' Metody obiektu stack</span>
<span class="c">'---------------------</span>

<span class="c">' Konstruktor</span>
<span class="c">'------------</span>
<span class="i">Constructor</span> <span class="v">stack</span>()
  <span class="v">S</span> = <span class="n">0</span>
<span class="i">End</span> <span class="i">Constructor</span>

<span class="c">' Destruktor</span>
<span class="c">'-----------</span>
<span class="i">Destructor</span> <span class="v">stack</span>()
  <span class="i">While</span> <span class="v">S</span>
    <span class="v">pop</span>()
  <span class="i">Wend</span>
<span class="i">End</span> <span class="i">Destructor</span>

<span class="c">' Sprawdza, czy stos jest pusty</span>
<span class="c">'------------------------------</span>
<span class="i">Function</span> <span class="v">stack</span>.<span class="v">empty</span>() <span class="i">As</span> <span class="i">Integer</span>
  <span class="i">If</span> <span class="v">S</span> = <span class="n">0</span> <span class="i">Then</span> <span class="i">Return</span> <span class="n">1</span>
  <span class="i">Return</span> <span class="n">0</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' Zwraca szczyt stosu.</span>
<span class="c">'------------------------------</span>
<span class="i">Function</span> <span class="v">stack</span>.<span class="v">top</span>() <span class="i">As</span> <span class="i">Integer</span>
  <span class="v">top</span> = <span class="v">S</span>-&gt;<span class="v">v</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' Zapisuje na stos</span>
<span class="c">'-----------------</span>
<span class="i">Sub</span> <span class="v">stack</span>.<span class="v">push</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>)
  <span class="i">Dim</span> <span class="v">e</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">e</span> = <span class="i">New</span> <span class="v">slistEl</span>
  <span class="v">e</span>-&gt;<span class="v">v</span>    = <span class="v">v</span>
  <span class="v">e</span>-&gt;<span class="i">Next</span> = <span class="v">S</span>
  <span class="v">S</span> = <span class="v">e</span>
<span class="i">End</span> <span class="i">Sub</span>

<span class="c">' Usuwa ze stosu</span>
<span class="c">'---------------</span>
<span class="i">Sub</span> <span class="v">stack</span>.<span class="v">pop</span>()
  <span class="i">Dim</span> <span class="v">e</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="i">If</span> <span class="v">S</span> <span class="i">Then</span>
    <span class="v">e</span> = <span class="v">S</span>
    <span class="v">S</span> = <span class="v">S</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">e</span>
  <span class="i">End</span> <span class="i">If</span>
<span class="i">End</span> <span class="i">Sub</span>

<span class="c">' Funkcja oblicza liczbê spójnych sk³adowych w grafie</span>
<span class="c">' n    - liczba wierzcho³ków w grafie</span>
<span class="c">' graf - tablica list s±siedztwa</span>
<span class="c">' VU   - tablica dostêpno¶ci krawêdzi grafu</span>
<span class="c">'----------------------------------------------------</span>
<span class="i">Function</span> <span class="v">ccn</span>(<span class="i">Byval</span> <span class="v">n</span> <span class="i">As</span> <span class="i">Integer</span>, <span class="i">Byval</span> <span class="v">graf</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span>, <span class="i">Byval</span> <span class="v">VU</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span>) <span class="i">As</span> <span class="i">Integer</span>

  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">C</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">cc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">stack</span> <span class="v">S</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>

  <span class="v">C</span> = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]        <span class="c">' Tworzymy tablicê spójnych sk³adowych</span>

  <span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
    <span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span>                 <span class="c">' Zerujemy tablicê spójnych sk³adowych</span>
  <span class="i">Next</span>

  <span class="v">cc</span> = <span class="n">0</span>                     <span class="c">' Zerujemy licznik spójnych sk³adowych</span>

  <span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
    <span class="i">If</span> <span class="v">C</span>[<span class="v">i</span>] = <span class="n">0</span> <span class="i">Then</span>         <span class="c">' Szukamy nieodwiedzonego jeszcze wierzcho³ka</span>
      <span class="v">cc</span> += <span class="n">1</span>                <span class="c">' Zwiêkszamy licznik sk³adowych</span>
      <span class="v">S</span>.<span class="v">push</span>(<span class="v">i</span>)              <span class="c">' Na stosie umieszczamy numer bie¿±cego wêz³a</span>
      <span class="v">C</span>[<span class="v">i</span>] = <span class="v">cc</span>              <span class="c">' Wierzcho³ek numerujemy i oznaczamy jako odwiedzony      </span>
      <span class="i">While</span> <span class="v">S</span>.<span class="v">empty</span>() = <span class="n">0</span>    <span class="c">' Przechodzimy graf algorytmem DFS</span>
        <span class="v">v</span> = <span class="v">S</span>.<span class="v">top</span>()          <span class="c">' Pobieramy wierzcho³ek</span>
        <span class="v">S</span>.<span class="v">pop</span>()              <span class="c">' Usuwamy go ze stosu</span>
        <span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]          <span class="c">' Przegl±damy s±siadów wierzcho³ka v</span>
        <span class="i">While</span> <span class="v">p</span>
          <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>
          <span class="i">If</span> ((<span class="v">VU</span>[<span class="v">v</span>] = <span class="n">1</span>) <span class="i">Orelse</span> (<span class="v">VU</span>[<span class="v">u</span>] = <span class="n">1</span>)) <span class="i">Andalso</span> (<span class="v">C</span>[<span class="v">u</span>] = <span class="n">0</span>) <span class="i">Then</span>
            <span class="v">S</span>.<span class="v">push</span>(<span class="v">p</span>-&gt;<span class="v">v</span>)     <span class="c">' Na stos id± s±siedzi nieodwiedzeni</span>
            <span class="v">C</span>[<span class="v">u</span>] = <span class="v">cc</span>        <span class="c">' i ponumerowani</span>
          <span class="i">End</span> <span class="i">If</span> 
          <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
        <span class="i">Wend</span>
      <span class="i">Wend</span>
    <span class="i">End</span> <span class="i">If</span>
  <span class="i">Next</span>
  
  <span class="i">Delete</span> [] <span class="v">C</span>                <span class="c">' Usuwamy tablicê C</span>

  <span class="i">Return</span> <span class="v">cc</span>                  <span class="c">' Zwracamy wynik</span>

<span class="i">End</span> <span class="i">Function</span>

<span class="c">' **********************</span>
<span class="c">' *** Program g³ówny ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">nc</span>,<span class="v">i</span>,<span class="v">v</span>,<span class="v">u</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">A</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">L</span>,<span class="v">p</span>,<span class="v">r</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="i">Byte</span> <span class="i">Ptr</span> <span class="v">VU</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">n</span>,<span class="v">m</span>                 <span class="c">' Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

<span class="v">A</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]      <span class="c">' Tworzymy tablice dynamiczne</span>
<span class="v">VU</span> = <span class="i">New</span> <span class="i">Byte</span> [<span class="v">n</span>]            <span class="c">' Krawêdzie aktywne</span>

<span class="c">' Tablicê A wype³niamy pustymi listami, a tablicê C wype³niamy zerami</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">A</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">VU</span>[<span class="v">i</span>] = <span class="n">1</span>
<span class="i">Next</span>

<span class="c">' Odczytujemy kolejne definicje krawêdzi.</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">u</span>               <span class="c">' Wierzcho³ki tworz±ce krawêd¼</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' Tworzymy nowy element</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>                   <span class="c">' Numerujemy go jako u</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">A</span>[<span class="v">v</span>]             <span class="c">' Dodajemy go na pocz±tek listy A[v]</span>
  <span class="v">A</span>[<span class="v">v</span>] = <span class="v">p</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' To samo dla krawêdzi w drug± stronê</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">A</span>[<span class="v">u</span>]
  <span class="v">A</span>[<span class="v">u</span>] = <span class="v">p</span>
<span class="i">Next</span>

<span class="c">' Algorytm znajdowania mostów</span>

<span class="v">L</span> = <span class="n">0</span>                        <span class="c">' Pusta lista mostów</span>

<span class="v">nc</span> = <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>)             <span class="c">' Zapamiêtujemy liczbê spójnych sk³adowych</span>

<span class="i">For</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>           <span class="c">' Przechodzimy przez kolejne wierzcho³ki grafu</span>
  <span class="v">p</span> = <span class="v">A</span>[<span class="v">v</span>]                   <span class="c">' Przegl±damy listê s±siedztwa wierzcho³ka v</span>
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>                 <span class="c">' u - numer wierzcho³ka s±siedniego w grafie</span>
    <span class="i">If</span> <span class="v">u</span> &gt; <span class="v">v</span> <span class="i">Then</span>            <span class="c">' Interesuj± nas tylko krawêdzie w jedn± stronê</span>
      <span class="v">VU</span>[<span class="v">v</span>] = <span class="n">0</span>              <span class="c">' Zaznaczamy krawêd¼ v-u jako usuniêt±</span>
      <span class="v">VU</span>[<span class="v">u</span>] = <span class="n">0</span>
      <span class="i">If</span> <span class="v">ccn</span>(<span class="v">n</span>,<span class="v">A</span>,<span class="v">VU</span>) &gt; <span class="v">nc</span> <span class="i">Then</span>
        <span class="v">r</span> = <span class="i">New</span> <span class="v">slistEl</span>      <span class="c">' Znaleziony most dodajemy do listy L</span>
        <span class="v">r</span>-&gt;<span class="v">v</span> = <span class="v">u</span>
        <span class="v">r</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
        <span class="v">L</span> = <span class="v">r</span>
        <span class="v">r</span> = <span class="i">New</span> <span class="v">slistEl</span>
        <span class="v">r</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
        <span class="v">r</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
        <span class="v">L</span> = <span class="v">r</span>
      <span class="i">End</span> <span class="i">If</span>
      <span class="v">VU</span>[<span class="v">v</span>] = <span class="n">1</span>              <span class="c">' Kasujemy zaznaczenie krawêdzi jako usuniêtej</span>
      <span class="v">VU</span>[<span class="v">u</span>] = <span class="n">1</span>
    <span class="i">End</span> <span class="i">If</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Print</span>

<span class="c">' Wypisujemy znalezione mosty, jednocze¶nie usuwaj±c listê L</span>

<span class="v">v</span> = <span class="n">0</span>

<span class="i">While</span> <span class="v">L</span>
  <span class="i">Print</span> <span class="v">L</span>-&gt;<span class="v">v</span>;
  <span class="v">v</span> = (<span class="v">v</span> + <span class="n">1</span>) <span class="i">Mod</span> <span class="n">2</span>
  <span class="i">If</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">Then</span> <span class="i">Print</span>
  <span class="v">p</span> = <span class="v">L</span>
  <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="i">Next</span>
  <span class="i">Delete</span> [] <span class="v">p</span>
<span class="i">Wend</span>

<span class="c">' Usuwamy dynamiczne struktury danych</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">p</span> = <span class="v">A</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">r</span> = <span class="v">p</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">r</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">A</span>
<span class="i">Delete</span> [] <span class="v">VU</span>

<span class="i">End</span> </pre></pre></td>
		</tr>
		<tr>
			<td style="text-align: center" bgcolor="#F0F0F0" colspan="2"><b>Wynik</b></td>
		</tr>
		<tr>
			<td style="text-align: left" class="program">17 17<br>0 1 0 2 0 3<br>1 2 1 14<br>4 11 4 12<br>5 6 5 9<br>6 7 6 8<br>10 15<br>11 15<br>12 15<br>13 14 13 16<br>14 16<br>
			<br>10 15<br>6 7<br>6 8<br>5 6<br>5 9<br>1 14<br>0 3</td>
			<td style="text-align: center">
			<img src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_01.gif" width="382" height="354"></td>
		</tr>
	</tbody></table>
	</div>
	</div>
	<p>&nbsp;</p><h3><a name="P2"></a>Rozwi±zanie nr 2</h3>
<div class="sb1">Teraz zaprezentujemy lepszy algorytm wyszukiwania mostów w 
	grafie nieskierowanym <span class="rem">(w literaturze nosi on nazwê 
	algorytmu
	<a target="_blank" href="http://pl.wikipedia.org/wiki/Robert_Tarjan">R. 
	Tarjana</a>)</span>. Algorytm bazuje na idei <a href="https://eduinf.waw.pl/inf/alg/001_search/0130.php">drzewa rozpinaj±cego</a> oraz 
	wykorzystuje w specyficzny sposób przej¶cie <a href="https://eduinf.waw.pl/inf/alg/001_search/0125.php">DFS</a>. Na pocz±tek kilka 
	spostrze¿eñ, które ten algorytm wykorzystuje.<p>&nbsp;</p>
	<p>
	<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_02.gif" width="254" height="228" style="float: left; margin-right: 16"></p>
	<div class="bl1"><font color="#FF0000">Most nie mo¿e byæ czê¶ci± cyklu</font>. 
		Uzasadnienie jest proste i wynika bezpo¶rednio z definicji mostu. Most 
		jest krawêdzi±, której usuniêcie dzieli sk³adow± grafu na dwie oddzielne 
		sk³adowe, czyli takie, dla których nie istnieje droga prowadz±ca od 
		jednej sk³adowej do drugiej. Lecz cykl w grafie nieskierowanym zawsze 
		mo¿na przebyæ w obu kierunkach, czyli pomiêdzy ka¿dymi dwoma 
		wierzcho³kami cyklu zawsze istniej± co najmniej dwie ró¿ne drogi 
		doj¶cia.<p>Na rysunku obok widzimy fragment grafu. Krawêd¼ ³±cz±ca 
		wierzcho³ki A i B nale¿y do cyklu A&#8211;B&#8211;C&#8211;D&#8211;E&#8211;A. 
		Gdyby by³a mostem, to jej usuniêcie spowodowa³oby, i¿ od wierzcho³ka A 
		do B przesta³aby istnieæ w grafie droga <span class="rem">(wierzcho³ki 
		te znalaz³yby siê w oddzielnych sk³adowych)</span>. Tymczasem od A do B 
		mo¿emy doj¶æ id±c wzd³u¿ krawêdzi cyklu w drug± stronê. To samo dotyczy 
		dowolnej innej krawêdzi nale¿±cej do tego cyklu.</p>
		<p><font color="#FF0000">Most musi nale¿eæ do drzewa rozpinaj±cego</font>. 
		To spostrze¿enie wynika z poprzedniego oraz z w³asno¶ci drzew 
		rozpinaj±cych. Drzewo rozpinaj±ce jest grafem acyklicznym. Krawêdzie 
		grafu, które nie znalaz³y siê w drzewie rozpinaj±cym, s± krawêdziami 
		tworz±cymi cykl, poniewa¿ prowadz± zawsze do wierzcho³ków, które 
		wcze¶niej odwiedzi³a procedura przej¶cia grafu DFS lub BFS. S± to tzw.
		<b>krawêdzie wtórne</b> <span class="rem" lang="en">(ang. back edges)</span>. 
		Skoro tak, to krawêdzie te nie mog± byæ mostami, poniewa¿ nale¿± do 
		cykli. Pozostaje zatem rozwa¿enie tylko tych krawêdzi, które s± zawarte 
		w drzewie rozpinaj±cym grafu.<br clear="all">
		</p>
		<div align="center">
			<table border="0" cellpadding="4" cellspacing="0">
				<tbody><tr>
					<td>
					<p style="text-align: center">Przyk³adowy graf<br>
				<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130_04.gif" width="271" height="249"></p></td>
					<td><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
					<td>
					<p style="text-align: center">Drzewo rozpinaj±ce grafu<br>
				<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130_05.gif" width="271" height="249"></p></td>
				</tr>
			</tbody></table>
			<p style="text-align: center">&nbsp;</p></div>
		<p>Zwróæ uwagê, ¿e ka¿da z szarych krawêdzi <span class="rem">(czyli 
		takich, które nie nale¿± do drzewa rozpinaj±cego)</span> tworzy cykl z 
		krawêdziami czarnymi.</p></div>
	<p>&nbsp;</p>
	<p>W algorytmie Tarjana wykorzystuje siê <a href="https://eduinf.waw.pl/inf/alg/001_search/0109.php#P4">przej¶cie 
	wsteczne</a> drzewa rozpinaj±cego grafu <span class="rem" lang="en">(ang. 
	post-order traversal)</span>. Przej¶cie to wykorzystuje 
	algorytm DFS w sposób nastêpuj±cy:</p>
	<div class="bl1">
		<ol>
			<li>Oznaczamy bie¿±cy wierzcho³ek jako odwiedzony.</li>
			<li>Przetwarzamy wszystkich nieodwiedzonych jeszcze s±siadów 
			bie¿±cego wierzcho³ka.</li>
			<li>Przetwarzamy wierzcho³ek bie¿±cy.</li>
		</ol>
	</div>
	<p>Przej¶cie DFS wykorzystywane jest do numerowania odwiedzanych 
	wierzcho³ków oraz do wyznaczania dla ka¿dego z nich dodatkowego 
	parametru <nobr>Low(<i>v</i>).</nobr> Parametr <i>Low</i>(<i>v</i>) dla danego 
	wierzcho³ka <i>v</i> jest najmniejsz± liczb± z numeru wierzcho³ka <i>v</i> 
	nadanego mu przez DFS, 
	parametrów <i>Low</i> wszystkich jego synów na drzewie rozpinaj±cym oraz numerów 
	DFS 
	wierzcho³ków po³±czonych z <i>v</i> za pomoc± krawêdzi wtórnych
	<span class="rem">(czyli tych, które nie zosta³y umieszczone na drzewie 
	rozpinaj±cym)</span>. Je¶li napotkamy wierzcho³ek <i>v</i>, którego numer 
	nadany przez DFS jest równy parametrowi Low(<i>v</i>) i wierzcho³ek ten posiada na 
	drzewie rozpinaj±cym ojca, to krawêd¼ od tego ojca do wierzcho³ka <i>v</i> 
	jest mostem.</p>
	<p>Prze¶led¼my na prostym przyk³adzie kolejne kroki algorytmu Tarjana.</p>
	<p>&nbsp;</p>
	<table border="0" cellpadding="4" cellspacing="0" class="sb1">
		<tbody><tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_03.gif" width="192" height="210"></td>
			<td nowrap=""><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
			<td>Oto nasz przyk³adowy graf, w którym mamy znale¼æ wszystkie 
			mosty. Graf przejdziemy algorytmem DFS, tworz±c po drodze drzewo 
			rozpinaj±ce w g³±b oraz numeruj±c wierzcho³ki grafu
			<span class="rem">(numeracja DFS nie ma nic wspólnego z numerami 
			wierzcho³ków w definicji grafu &#8211; okre¶la ona kolejno¶æ 
			odwiedzin poszczególnych wierzcho³ków)</span>. Numery te pos³u¿± 
			pó¼niej do wyznaczenia dla ka¿dego wierzcho³ka parametru Low, gdy 
			zostan± ju¿ przetworzeni wszyscy s±siedzi.</td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_04.gif" width="192" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Przej¶cie DFS rozpoczynamy od wierzcho³ka nr 0 <span class="rem">
			(mo¿e to byæ dowolny inny wierzcho³ek grafu)</span>. Wierzcho³ek ten 
			otrzymuje numer 1 <span class="rem">(numery wierzcho³ków nadane 
			przez DFS bêdziemy oznaczaæ kolorem czerwonym)</span>, zostaje 
			oznaczony jako odwiedzony, po czym rekurencyjnie algorytm DFS 
			odwiedza wszystkich nieodwiedzonych jeszcze s±siadów. Przej¶cie do 
			s±siada tworzy ga³±¼ w drzewie rozpinaj±cym, któr± nale¿y zapamiêtaæ 
			w osobnej strukturze danych.</td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_05.gif" width="192" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Zatem z wierzcho³ka nr 0 przechodzimy do wierzcho³ka nr 2. 
			Oznaczamy go jako odwiedzonego i numerujemy liczb± 2. Krawêd¼ <nobr>
			0 &#8211; 1</nobr> staje siê krawêdzi± drzewa rozpinaj±cego.<p>
			Odwiedzamy rekurencyjnie wszystkich s±siadów wierzcho³ka nr 1.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_06.gif" width="192" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Przechodzimy do wierzcho³ka nr 2. Oznaczamy go jako odwiedzonego 
			i numerujemy liczb± 3. Krawêd¼ 1 &#8211; 2 jest do³±czana do drzewa 
			rozpinaj±cego.<p>Poniewa¿ wszyscy s±siedzi wierzcho³ka nr 2 zostali 
			ju¿ odwiedzeni, to przechodzimy do przetwarzania samego wierzcho³ka 
			nr 2. Polega ono na wyznaczeniu parametru Low dla tego wierzcho³ka. 
			Bêdzie to najmniejsza warto¶æ z 3 i 1, czyli 1 <span class="rem">(3 &#8211; 
			numer wierzcho³ka nadany przez DFS, 1 &#8211; numer wierzcho³ka 
			po³±czonego krawêdzi± wtórn± 2 &#8211; 0)</span>. Poniewa¿ Low(2) 
			= 1 jest ró¿ne od numeru 3, który wierzcho³kowi nada³o DFS, zatem 
			krawêd¼ 1 &#8211; 2 <span class="rem">(ojciec &#8211; syn na drzewie 
			rozpinaj±cym)</span> nie jest mostem..</p>
			<p>Wracamy z powrotem do wierzcho³ka nr 1, z którego tutaj 
			przyszli¶my.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_07.gif" width="192" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Z wierzcho³ka nr 1 przechodzimy do kolejnego nieodwiedzonego 
			s±siada, czyli do wierzcho³ka nr 4.<p>Wierzcho³ek nr 4 oznaczamy jako 
			odwiedzony, nadajemy mu numer 4. Krawêd¼ 1 &#8211; 4 zostaje dodana 
			do drzewa rozpinaj±cego.</p>
			<p>Wierzcho³ek nr 4 posiada dwóch nieodwiedzonych s±siadów: 3 i 5.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_08.gif" width="195" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Z wierzcho³ka nr 4 przechodzimy do wierzcho³ka nr 3. Oznaczamy 
			go jako odwiedzony i nadajemy mu numer 5. Krawêd¼ 4 &#8211; 5 trafia 
			do drzewa rozpinaj±cego.<p>Wierzcho³ek nr 3 posiada nieodwiedzonego 
			jeszcze s±siada nr 5.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_09.gif" width="195" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Z wierzcho³ka nr 3 przechodzimy do wierzcho³ka nr 5. Oznaczamy 
			go jako odwiedzony i nadajemy mu numer 6. Krawêd¼ 3 &#8211; 5 
			do³±czamy do drzewa rozpinaj±cego.<p>Wierzcho³ek nr 5 nie posiada 
			wiêcej nieodwiedzonych s±siadów. Zatem wyliczamy dla niego parametr 
			Low jako mniejsz± liczbê z 6 <span class="rem">(numer nadany 
			wierzcho³kowi 5 przez DFS)</span> i 4 <span class="rem">(numer DFS 
			wierzcho³ka 4, do którego prowadzi krawêd¼ wtórna)</span>.</p>
			<p>Low(5) = min(6,4) = 4</p>
			<p>Poniewa¿ parametr Low ma dla tego wierzcho³ka warto¶æ ró¿n± od 
			numeru nadanego przez DFS, krawêd¼ 3 &#8211; 5 nie jest mostem.</p>
			<p>Przetwarzanie wierzcho³ka nr 5 jest zakoñczone, wracamy do 
			wierzcho³ka nr 3, z którego przyszli¶my.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_10.gif" width="207" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Jeste¶my w wierzcho³ku nr 3. Wszyscy s±siedzi zostali 
			odwiedzeni. Wyliczamy parametr Low(3) jako najmniejsz± liczbê z 5
			<span class="rem">(numer DFS wierzcho³ka 3)</span> i 4
			<span class="rem">(parametr Low wierzcho³ka nr 6, który jest synem)</span>.<p>
			Low(3) = min (5,4) = 4</p>
			<p>Poniewa¿ Low(3) = 4 jest ró¿ne od numeru DFS równego 5 dla 
			wierzcho³ka nr 3, krawêd¼ 4 &#8211; 3 nie jest mostem.</p>
			<p>Wracamy do wierzcho³ka nr 4.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_11.gif" width="207" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Jeste¶my w wierzcho³ku nr 4. Wszyscy s±siedzi wierzcho³ka nr 4 
			s± odwiedzeni. Obliczamy Low(4) jako najmniejsz± liczbê z 4
			<span class="rem">(numer DFS wierzcho³ka nr 4)</span>, 4
			<span class="rem">(parametr Low(3) = 4, poniewa¿ wierzcho³ek nr 3 
			jest synem wierzcho³ka nr 4 na drzewie rozpinaj±cym)</span> oraz 6
			<span class="rem">(numer DFS wierzcho³ka nr 5, który ³±czy siê z nim 
			krawêdzi± wtórn±)</span>.<p>Low(4) = min (4,4,6) = 4</p>
			<p>Poniewa¿ parametr Low jest równy numerowi DFS, to krawêd¼ 1 &#8211; 
			4 jest mostem.</p>
			<p>Wracamy do wierzcho³ka nr 1.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_12.gif" width="207" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Jeste¶my w wierzcho³ku nr 1. Wszyscy jego s±siedzi s± 
			odwiedzeni. Obliczamy Low(1) jako najmniejsz± liczbê z 2
			<span class="rem">(numer DFS wierzcho³ka 1)</span> i 1
			<span class="rem">(parametr Low(2) = 1, poniewa¿ wierzcho³ek nr 2 
			jest synem na drzewie rozpinaj±cym)</span>.<p>Low(1) = min (2,1) = 1</p>
			<p>Parametr Low ró¿ni siê od numeru DFS, zatem krawêd¼ 0 &#8211; 1 
			nie jest mostem.</p></td>
		</tr>
		<tr>
			<td style="text-align: left">
			<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_13.gif" width="207" height="210"></td>
			<td nowrap="">&nbsp;</td>
			<td>Jeste¶my w wierzcho³ku startowym nr 0. Wszyscy s±siedzi zostali 
			ju¿ odwiedzeni. Obliczamy Low(0) jako najmniejsz± liczbê z 1
			<span class="rem">(numer DFS wierzcho³ka 0)</span>, 1
			<span class="rem">(parametr Low(1), poniewa¿ wierzcho³ek nr 1 jest 
			synem na drzewie rozpinaj±cym)</span> i 3 <span class="rem">(numer 
			DFS wierzcho³ka 2, który ³±czy siê krawêdzi± wtórn±)</span>.<p>
			Low(0) = min (1,1,3) = 1</p>
			<p>Mamy równo¶æ parametru Low(0) z numerem DFS. Jednak¿e wierzcho³ek 
			nr 0 nie posiada ojca na drzewie rozpinaj±cym, zatem nie istnieje 
			³±cz±ca go z nim krawêd¼-most.</p>
			<p>Ca³y graf zosta³ przetworzony. Algorytm Tarjana koñczy siê.</p>
			</td>
		</tr>
	</tbody></table>
	<p>&nbsp;</p>
	<p>Zwróæ uwagê, ¿e wszystkie mosty w danej spójnej sk³adowej grafu 
			zostan± znalezione w jednym przej¶ciu DFS. Zatem otrzymujemy 
	algorytm dzia³aj±cy w czasie liniowym.</p>
	<p>&nbsp;</p>
<h4><a name="A2"></a>Algorytm Tarjana wyszukiwania mostów w grafie 
nieskierowanym</h4>
<h5>Funkcja rekurencyjna DFSb(v,vf,graf,D,cv,L)</h5>
	<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table259" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>v</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>wierzcho³ek startowy, <i>v</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>vf</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>ojciec wierzcho³ka <i>v </i>na drzewie rozpinaj±cym w g³±b, <i>vf</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>D</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>tablica numerów DFS dla poszczególnych wierzcho³ków</td>
  </tr>
  <tr>
    <td valign="top" nowrap="">cv</td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>referencja do zmiennej zewnêtrznej przechowuj±cej numery wierzcho³ków. 
	Przy pierwszym wywo³aniu zmienna powinna zawieraæ 1. cv 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista mostów. Przechowuje numery wierzcho³ka startowego i koñcowego 
	krawêdzi-mostu.</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
Warto¶æ parametru <i>Low</i> dla wierzcho³ka <i>v</i>. Je¶li zostanie znaleziony 
most, to bêdzie on dopisany do listy <i>L</i>.</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table261" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>Low</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>warto¶æ parametru Low dla bie¿±cego wierzcho³ka, <i>Low</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>temp</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>chwilowo przechowuje wynik wywo³ania rekurencyjnego, <i>t</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table262">
    <tbody><tr>
      <td valign="top">K01:</td>
      <td nowrap="" valign="top"><i>D</i>[<i>v</i>] &#8592; cv</td>
      <td class="c" valign="top">; numerujemy wierzcho³ek</td>
    </tr>
    <tr>
      <td valign="top">K02</td>
      <td nowrap="" valign="top"><i>Low</i> &#8592; cv</td>
      <td class="c" valign="top">; wstêpna warto¶æ parametru </td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top">cv &#8592; cv + 1</td>
      <td class="c" valign="top">; kolejny wierzcho³ek bêdzie mia³ numer o 1 
		wiêkszy</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top"><b>Dla</b> ka¿dego s±siada <i>u</i> wierzcho³ka <i>
		v</i>, <b>wykonuj</b> K05...K10</td>
      <td class="c" valign="top">; przegl±damy wszystkich s±siadów wierzcho³ka 
		bie¿±cego</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>u</i> = <i>vf</i>,
		<b>to nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">; pomijamy ojca na drzewie rozpinaj±cym</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>u</i>] 
		= 0, <b>to id¼ do</b> K09</td>
      <td class="c" valign="top">; s±siad nieodwiedzony?</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>u</i>] 
		&lt; <i>Low</i>, <b>to</b> <i>Low</i> &#8592; <i>D</i>[<i>u</i>]</td>
      <td class="c" valign="top">; odwiedzony, krawêd¼ wtórna. Modyfikujemy 
		parametr Low</td>
    </tr>
    <tr>
      <td valign="top">K08:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K09:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <i>temp</i> &#8592; DFSb(<i>u</i>,<i>v,graf</i>,<i>T</i>,<i>D</i>,cv,<i>L</i>)</td>
      <td class="c" valign="top">; rekurencyjne wywo³anie funkcji</td>
    </tr>
    <tr>
      <td valign="top">K10:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>temp</i> &lt; <i>
		Low</i>, <b>to</b> <i>Low</i> &#8592; <i>temp</i></td>
      <td class="c" valign="top">; modyfikujemy parametr Low</td>
    </tr>
    <tr>
      <td valign="top">K11:</td>
      <td nowrap="" valign="top"><b>Je¶li</b> (<i>vf</i> &gt; -1)
	<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_12.gif" width="11" height="8"> 
		(<i>Low</i> = <i>D</i>[<i>v</i>]), <b>to</b> dodaj krawêd¼ <i>vf</i>,<i>v</i> 
		do listy <i>L</i></td>
      <td class="c" valign="top">; s±siedzi odwiedzeni. Sprawdzamy warunek mostu</td>
    </tr>
    <tr>
      <td valign="top">K12:</td>
      <td nowrap="" valign="top"><b>Zakoñcz z wynikiem</b> <i>Low</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    </tbody></table>
  <p>&nbsp;</p></div>
<h5>Algorytm g³ówny</h5>
	<h5>Wej¶cie</h5>
<div class="sb1">
<table id="table265" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap=""><i>n</i></td>
    <td valign="top">&nbsp;&#8211;<span lang="en">&nbsp;</span></td>
    <td>liczba wierzcho³ków w grafie, <i>n</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>graf</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>zadany w dowolnie wybrany sposób, algorytm tego nie precyzuje</td>
  </tr>
  </tbody></table>
</div>
<h5>Wyj¶cie:</h5>
<div class="sb1">
Lista <i>L</i> zawiera krawêdzie bêd±ce mostami</div>
<h5>Elementy pomocnicze:</h5>
<div class="sb1">
<table id="table266" style="BORDER-COLLAPSE: collapse" cellpadding="2" border="0">
  <tbody><tr>
    <td valign="top" nowrap="">cv</td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>przechowuje numery wierzcho³ków dla DFS, cv 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>D</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>dynamiczna tablica dla numerów wierzcho³ków nadawanych przez DFS. 
	Elementy s± liczbami ca³kowitymi.</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>L</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>lista par wierzcho³ków, które s± po³±czone mostem</td>
  </tr>
  <tr>
    <td valign="top" nowrap=""><i>i</i></td>
    <td valign="top"><span lang="en">&nbsp;</span>&#8211;<span lang="en">&nbsp;</span></td>
    <td>numery wierzcho³ków w grafie, <i>i</i> 
<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/000_symbol_05.gif" width="8" height="8">
	<span class="f">C</span></td>
  </tr>
  </tbody></table>
</div>
<h5><a href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#prezentacja">Lista kroków:</a></h5>
<div class="bl1">
  <table border="0" cellpadding="2" style="border-collapse: collapse" id="table267">
    <tbody><tr>
      <td valign="top">K01</td>
      <td nowrap="" valign="top">Twórz n elementow± tablicê <i>D</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K02:</td>
      <td nowrap="" valign="top">Zeruj tablicê <i>D</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K03:</td>
      <td nowrap="" valign="top">Twórz pust± listê <i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K04:</td>
      <td nowrap="" valign="top"><b>Dla</b> <i>i</i> = 0,1,...,<i>n</i>-1 <b>
		wykonuj</b> K05...K07</td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    <tr>
      <td valign="top">K05:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; <b>Je¶li</b> <i>D</i>[<i>i</i>] 
		&gt; 0, <b>to nastêpny obieg pêtli</b> K04</td>
      <td class="c" valign="top">; szukamy nieodwiedzonych jeszcze wierzcho³ków</td>
    </tr>
    <tr>
      <td valign="top">K06:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; cv &#8592; 1</td>
      <td class="c" valign="top">; numer DFS pierwszego wierzcho³ka</td>
    </tr>
    <tr>
      <td valign="top">K07:</td>
      <td nowrap="" valign="top">&nbsp;&nbsp;&nbsp; DFSb(<i>i</i>,-1<i>,graf</i>,<i>D</i>,cv,<i>L</i>)</td>
      <td class="c" valign="top">; szukamy mostów</td>
    </tr>
    <tr>
      <td valign="top">K08:</td>
      <td nowrap="" valign="top"><b>Zakoñcz z wynikiem </b><i>L</i></td>
      <td class="c" valign="top">&nbsp;</td>
    </tr>
    </tbody></table>
  	</div>
	<p>&nbsp;</p>
<h4>Program</h4> <div class="sb1"><table border="0" cellpadding="8" style="border-collapse: collapse" id="table263">
    <tbody><tr>
      <td class="note"><b>Wa¿ne</b>:<br>
 <p class="bl1">Zanim uruchomisz program, przeczytaj <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0001.php#konsola">wstêp</a> do tego artyku³u, w którym wyja¶niamy 
      funkcje tych programów oraz sposób korzystania z nich. </p></td></tr>
  </tbody></table>
  <p>&nbsp;</p></div>
<div class="sb1">
	Program odczytuje <a target="_blank" href="https://eduinf.waw.pl/inf/alg/001_search/0124.php#P1">definicjê</a> grafu 
	nieskierowanego, wyszukuje w nim wszystkie mosty i wy¶wietla je w oknie 
	konsoli. Aby upro¶ciæ funkcjê rekurencyjn± DFSb(), wiêkszo¶æ jej parametrów 
	zosta³a zrealizowana jako zmienne globalne.<p>&nbsp;</p>
	<p>Przyk³adowe dane <span class="rem">(spójne sk³adowe 
	zosta³y pokolorowane w celach testowych)</span>:</p>
	<table border="0" cellpadding="4" cellspacing="0">
			<tbody><tr>
				<td>
				<img border="0" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0129_03.gif" width="382" height="354"></td>
				<td><span lang="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
				<td>17 17<br>
				0 1 0 2 0 3<br>
				1 2 1 14<br>
				4 11 4 12<br>
				5 6 5 9<br>
				6 7 6 8<br>
				10 15<br>
				11 15<br>
				12 15<br>
				13 14 13 16<br>
				14 16</td>
			</tr>
		</tbody></table>
	<p>&nbsp;</p>
	<table border="1" id="table264" cellspacing="0" cellpadding="4" style="border-collapse: collapse" bordercolor="#808080">
		<tbody><tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Lazarus</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="pas"><pre><span class="c">// Wyszukiwanie mostów w grafie nieskierowanym</span>
<span class="c">// Data: 28.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//--------------------------------------------</span>

<span class="i">program</span> <span class="v">bridges</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa i listy mostów</span>
<span class="i">type</span>
  <span class="v">PslistEl</span> = ^<span class="v">slistEl</span>;
  <span class="v">slistEl</span> =  <span class="i">record</span>
    <span class="v">next</span>  : <span class="v">PslistEl</span>;
    <span class="v">v</span>     : <span class="v">integer</span>;
  <span class="i">end</span>;

<span class="v">TList</span> = <span class="i">array</span> <span class="i">of</span> <span class="v">PslistEl</span>;

<span class="c">// Zmienne globalne</span>

<span class="i">var</span>
  <span class="v">n</span>,<span class="v">m</span>,<span class="v">cv</span> : <span class="v">integer</span>;           <span class="c">// Liczba wierzcho³ków, krawêdzi, numeracja</span>
  <span class="v">graf</span>   : <span class="v">TList</span>;             <span class="c">// Tablica list s±siedztwa</span>
  <span class="v">D</span>      : <span class="i">array</span> <span class="i">of</span> <span class="v">integer</span>;  <span class="c">// Numery DFS</span>
  <span class="v">L</span>      : <span class="v">PslistEl</span>;          <span class="c">// Lista mostów</span>

<span class="c">// Funkcja rekurencyjna wyszukuj±ca mosty</span>
<span class="c">// v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">// vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">// Reszta parametrów to zmienne globalne</span>
<span class="c">//----------------------------------------------------------</span>
<span class="i">function</span> <span class="v">DFSb</span>(<span class="v">v</span>,<span class="v">vf</span> : <span class="v">integer</span>) : <span class="v">integer</span>;
<span class="i">var</span>
  <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span> : <span class="v">integer</span>;
  <span class="v">p</span>          : <span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="v">D</span>[<span class="v">v</span>] := <span class="v">cv</span>;                 <span class="c">// Numerujemy wierzcho³ek</span>
  <span class="v">Low</span>  := <span class="v">cv</span>;                 <span class="c">// Wstêpna warto¶æ parametru Low</span>
  <span class="v">inc</span>(<span class="v">cv</span>);                    <span class="c">// Nastêpny numer wierzcho³ka</span>

  <span class="v">p</span> := <span class="v">graf</span>[<span class="v">v</span>];               <span class="c">// Przegl±damy listê s±siadów</span>
  <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">u</span> := <span class="v">p</span>^.<span class="v">v</span>;                <span class="c">// u - numer wierzcho³ka s±siada</span>
    <span class="i">if</span> <span class="v">u</span> &lt;&gt; <span class="v">vf</span> <span class="i">then</span>           <span class="c">// u nie mo¿e byæ ojcem v</span>
    <span class="i">begin</span>
      <span class="i">if</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">then</span>        <span class="c">// Je¶li s±siad u nie by³ odwiedzany, to</span>
      <span class="i">begin</span>
        <span class="v">temp</span> := <span class="v">DFSb</span>(<span class="v">u</span>,<span class="v">v</span>);    <span class="c">// rekurencyjnie odwiedzamy go</span>
        <span class="i">if</span> <span class="v">temp</span> &lt; <span class="v">Low</span> <span class="i">then</span> <span class="v">Low</span> := <span class="v">temp</span>;
      <span class="i">end</span>
      <span class="i">else</span> <span class="i">if</span> <span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span> <span class="i">then</span> <span class="v">Low</span> := <span class="v">D</span>[<span class="v">u</span>];
    <span class="i">end</span>;
    <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;             <span class="c">// Nastêpny wierzcho³ek na li¶cie</span>
  <span class="i">end</span>;

  <span class="c">// Wszyscy s±siedzi zostali odwiedzeni. Teraz robimy test na most</span>

  <span class="i">if</span> (<span class="v">vf</span> &gt; -<span class="n">1</span>) <span class="i">and</span> (<span class="v">Low</span> = <span class="v">D</span>[<span class="v">v</span>]) <span class="i">then</span>
  <span class="i">begin</span>
    <span class="v">new</span>(<span class="v">p</span>);                   <span class="c">// Mamy most. Dodajemy go do listy L</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">p</span>;
    <span class="v">new</span>(<span class="v">p</span>);
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">vf</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">p</span>;
  <span class="i">end</span>;

  <span class="v">DFSb</span> := <span class="v">Low</span>;                <span class="c">// Wynik</span>
<span class="i">end</span>;

<span class="c">// **********************</span>
<span class="c">// *** Program g³ówny ***</span>
<span class="c">// **********************</span>

<span class="i">var</span>
  <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span> : <span class="v">integer</span>;           <span class="c">// Numery wierzcho³ków</span>
  <span class="v">p</span>,<span class="v">r</span>   : <span class="v">PslistEl</span>;
<span class="i">begin</span>
  <span class="v">read</span>(<span class="v">n</span>,<span class="v">m</span>);                 <span class="c">// Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="v">n</span>);        <span class="c">// Tworzymy zmienne dynamiczne</span>
  <span class="v">SetLength</span>(<span class="v">D</span>,<span class="v">n</span>);
  <span class="v">L</span> := <span class="v">nil</span>;

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">graf</span>[<span class="v">i</span>] := <span class="v">nil</span>;
    <span class="v">D</span>[<span class="v">i</span>]    := <span class="n">0</span>;
  <span class="i">end</span>;

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">m</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">read</span>(<span class="v">v</span>,<span class="v">u</span>);               <span class="c">// Wierzcho³ki tworz±ce krawêd¼</span>
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// Tworzymy nowy element</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">u</span>;               <span class="c">// Numerujemy go jako w</span>
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">v</span>];      <span class="c">// Dodajemy go na pocz±tek listy graf[v]</span>
    <span class="v">graf</span>[<span class="v">v</span>] := <span class="v">p</span>;
    <span class="v">new</span>(<span class="v">p</span>);                  <span class="c">// To samo dla krawêdzi w drug± stronê</span>
    <span class="v">p</span>^.<span class="v">v</span> := <span class="v">v</span>;
    <span class="v">p</span>^.<span class="v">next</span> := <span class="v">graf</span>[<span class="v">u</span>];
    <span class="v">graf</span>[<span class="v">u</span>] := <span class="v">p</span>;
  <span class="i">end</span>;

  <span class="c">// Szukamy mostów</span>

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
    <span class="i">if</span> <span class="v">D</span>[<span class="v">i</span>] = <span class="n">0</span> <span class="i">then</span>         <span class="c">// Szukamy nieodwiedzonego wierzcho³ka</span>
    <span class="i">begin</span>
      <span class="v">cv</span>   := <span class="n">1</span>;             <span class="c">// Pocz±tek numeracji DFS</span>
      <span class="v">DFSb</span>(<span class="v">i</span>,-<span class="n">1</span>);            <span class="c">// Szukamy mostów</span>
    <span class="i">end</span>;

  <span class="v">writeln</span>;

  <span class="c">// Wypisujemy znalezione mosty</span>

  <span class="v">v</span> := <span class="n">0</span>;

  <span class="i">while</span> <span class="v">L</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">write</span>(<span class="v">L</span>^.<span class="v">v</span>,<span class="t">' '</span>);
    <span class="v">v</span> := (<span class="v">v</span> + <span class="n">1</span>) <span class="i">mod</span> <span class="n">2</span>;
    <span class="i">if</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">then</span> <span class="v">writeln</span>;
    <span class="v">p</span> := <span class="v">L</span>;
    <span class="v">L</span> := <span class="v">L</span>^.<span class="v">next</span>;
    <span class="v">dispose</span>(<span class="v">p</span>);
  <span class="i">end</span>;

  <span class="c">// Usuwamy struktury dynamiczne</span>

  <span class="v">SetLength</span>(<span class="v">D</span>,<span class="n">0</span>);

  <span class="i">for</span> <span class="v">i</span> := <span class="n">0</span> <span class="i">to</span> <span class="v">n</span> - <span class="n">1</span> <span class="i">do</span>
  <span class="i">begin</span>
    <span class="v">p</span> := <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span> <span class="v">p</span> &lt;&gt; <span class="v">nil</span> <span class="i">do</span>
    <span class="i">begin</span>
      <span class="v">r</span> := <span class="v">p</span>;
      <span class="v">p</span> := <span class="v">p</span>^.<span class="v">next</span>;
      <span class="v">dispose</span>(<span class="v">r</span>);
    <span class="i">end</span>;
  <span class="i">end</span>;

  <span class="v">SetLength</span>(<span class="v">graf</span>,<span class="n">0</span>);
<span class="i">end</span>. </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Code::Blocks</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="cpp"><pre><span class="c">// Wyszukiwanie mostów w grafie nieskierowanym</span>
<span class="c">// Data: 28.12.2013</span>
<span class="c">// (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">//--------------------------------------------</span>

<span class="pp">#include &lt;iostream&gt;</span>

<span class="i">using</span> <span class="i">namespace</span> <span class="v">std</span>;

<span class="c">// Typy dla dynamicznej tablicy list s±siedztwa i listy mostów</span>

<span class="i">struct</span> <span class="v">slistEl</span>
{
  <span class="v">slistEl</span> * <span class="v">next</span>;
  <span class="i">int</span> <span class="v">v</span>;
};

<span class="c">// Zmienne globalne</span>

<span class="i">int</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">cv</span>;                   <span class="c">// Liczba wierzcho³ków, krawêdzi, numeracja</span>
<span class="v">slistEl</span> ** <span class="v">graf</span>;              <span class="c">// Tablica list s±siedztwa</span>
<span class="i">int</span> *<span class="v">D</span>;                       <span class="c">// Numery DFS</span>
<span class="v">slistEl</span> * <span class="v">L</span>;                  <span class="c">// Lista mostów</span>

<span class="c">// Funkcja rekurencyjna wyszukuj±ca mosty</span>
<span class="c">// v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">// vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">// Reszta parametrów to zmienne globalne</span>
<span class="c">//----------------------------------------------------------</span>
<span class="i">int</span> <span class="v">DFSb</span>(<span class="i">int</span> <span class="v">v</span>, <span class="i">int</span> <span class="v">vf</span>)
{
  <span class="i">int</span> <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span>;
  <span class="v">slistEl</span> * <span class="v">p</span>;

  <span class="c">// Numerujemy wierzcho³ek, ustalamy wstêpn± warto¶æ Low oraz zwiêkszamy numeracjê</span>

  <span class="v">D</span>[<span class="v">v</span>] = <span class="v">Low</span> = <span class="v">cv</span>++;

  <span class="i">for</span>(<span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]; <span class="v">p</span>; <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>) <span class="c">// Przegl±damy listê s±siadów</span>
  {
    <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>;                 <span class="c">// u - numer wierzcho³ka s±siada</span>
    <span class="i">if</span>(<span class="v">u</span> != <span class="v">vf</span>)               <span class="c">// u nie mo¿e byæ ojcem v</span>
    {
      <span class="i">if</span>(!<span class="v">D</span>[<span class="v">u</span>])               <span class="c">// Je¶li s±siad u nie by³ odwiedzany, to</span>
      {
        <span class="v">temp</span> = <span class="v">DFSb</span>(<span class="v">u</span>,<span class="v">v</span>);     <span class="c">// rekurencyjnie odwiedzamy go</span>
        <span class="i">if</span>(<span class="v">temp</span> &lt; <span class="v">Low</span>) <span class="v">Low</span> = <span class="v">temp</span>;
      }
      <span class="i">else</span> <span class="i">if</span>(<span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span>) <span class="v">Low</span> = <span class="v">D</span>[<span class="v">u</span>];
    }
  }

  <span class="c">// Wszyscy s±siedzi zostali odwiedzeni. Teraz robimy test na most</span>

  <span class="i">if</span>((<span class="v">vf</span> &gt; -<span class="n">1</span>) &amp;&amp; (<span class="v">Low</span> == <span class="v">D</span>[<span class="v">v</span>]))
  {
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;         <span class="c">// Mamy most. Dodajemy go do listy L</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">p</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">vf</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">p</span>;
  }

  <span class="i">return</span> <span class="v">Low</span>;                <span class="c">// Wynik</span>
}

<span class="c">// **********************</span>
<span class="c">// *** Program g³ówny ***</span>
<span class="c">// **********************</span>

<span class="i">int</span> <span class="v">main</span>()
{
  <span class="i">int</span> <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span>;                 <span class="c">// Numery wierzcho³ków</span>
  <span class="v">slistEl</span> *<span class="v">p</span>,*<span class="v">r</span>;

  <span class="v">cin</span> &gt;&gt; <span class="v">n</span> &gt;&gt; <span class="v">m</span>;             <span class="c">// Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

  <span class="v">graf</span> = <span class="i">new</span> <span class="v">slistEl</span> * [<span class="v">n</span>]; <span class="c">// Tworzymy zmienne dynamiczne</span>
  <span class="v">D</span> = <span class="i">new</span> <span class="i">int</span>[<span class="v">n</span>];
  <span class="v">L</span> = <span class="v">NULL</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">graf</span>[<span class="v">i</span>] = <span class="v">NULL</span>;
    <span class="v">D</span>[<span class="v">i</span>]    = <span class="n">0</span>;
  }

  <span class="c">// Odczytujemy kolejne definicje krawêdzi</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">m</span>; <span class="v">i</span>++)
  {
    <span class="v">cin</span> &gt;&gt; <span class="v">v</span> &gt;&gt; <span class="v">u</span>;           <span class="c">// Wierzcho³ki tworz±ce krawêd¼</span>
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;         <span class="c">// Tworzymy nowy element</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>;                <span class="c">// Numerujemy go jako w</span>
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">v</span>];       <span class="c">// Dodajemy go na pocz±tek listy graf[v]</span>
    <span class="v">graf</span>[<span class="v">v</span>] = <span class="v">p</span>;
    <span class="v">p</span> = <span class="i">new</span> <span class="v">slistEl</span>;         <span class="c">// To samo dla krawêdzi w drug± stronê</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>;
    <span class="v">p</span>-&gt;<span class="v">next</span> = <span class="v">graf</span>[<span class="v">u</span>];
    <span class="v">graf</span>[<span class="v">u</span>] = <span class="v">p</span>;
  }

  <span class="c">// Szukamy mostów</span>

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
    <span class="i">if</span>(!<span class="v">D</span>[<span class="v">i</span>])               <span class="c">// Szukamy nieodwiedzonego wierzcho³ka</span>
    {
      <span class="v">cv</span>   = <span class="n">1</span>;             <span class="c">// Pocz±tek numeracji DFS</span>
      <span class="v">DFSb</span>(<span class="v">i</span>,-<span class="n">1</span>);           <span class="c">// Szukamy mostów</span>
    }

  <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;

  <span class="c">// Wypisujemy znalezione mosty</span>

  <span class="v">v</span> = <span class="n">0</span>;

  <span class="i">while</span>(<span class="v">L</span>)
  {
    <span class="v">cout</span> &lt;&lt; <span class="v">L</span>-&gt;<span class="v">v</span> &lt;&lt; <span class="t">" "</span>;
    <span class="v">v</span> ^= <span class="n">1</span>;
    <span class="i">if</span>(!<span class="v">v</span>) <span class="v">cout</span> &lt;&lt; <span class="v">endl</span>;
    <span class="v">p</span> = <span class="v">L</span>;
    <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="v">next</span>;
    <span class="i">delete</span> <span class="v">p</span>;
  }

  <span class="c">// Usuwamy struktury dynamiczne</span>

  <span class="i">delete</span> [] <span class="v">D</span>;

  <span class="i">for</span>(<span class="v">i</span> = <span class="n">0</span>; <span class="v">i</span> &lt; <span class="v">n</span>; <span class="v">i</span>++)
  {
    <span class="v">p</span> = <span class="v">graf</span>[<span class="v">i</span>];
    <span class="i">while</span>(<span class="v">p</span>)
    {
      <span class="v">r</span> = <span class="v">p</span>;
      <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="v">next</span>;
      <span class="i">delete</span> <span class="v">r</span>;
    }
  }

  <span class="i">delete</span> <span class="v">graf</span>;

  <span class="i">return</span> <span class="n">0</span>;
} </pre></pre></td>
		</tr>
		<tr>
			<td bgcolor="#F0F0F0" style="text-align: center" colspan="2"><b>Free Basic</b></td>
		</tr>
		<tr>
			<td style="text-align: left" colspan="2">
			<pre id="bas"><pre><span class="c">' Wyszukiwanie mostów w grafie nieskierowanym</span>
<span class="c">' Data: 28.12.2013</span>
<span class="c">' (C)2013 mgr Jerzy Wa³aszek</span>
<span class="c">'--------------------------------------------</span>

<span class="c">' Typy dla dynamicznej tablicy list s±siedztwa i listy mostów</span>

<span class="i">Type</span> <span class="v">slistEl</span>
  <span class="i">Next</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span>
  <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>
<span class="i">End</span> <span class="i">Type</span>

<span class="c">' Zmienne globalne</span>

<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">n</span>,<span class="v">m</span>,<span class="v">cv</span>        <span class="c">' Liczba wierzcho³ków, krawêdzi, numeracja</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="i">Ptr</span> <span class="v">graf</span>  <span class="c">' Tablica list s±siedztwa</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="i">Integer</span> <span class="i">Ptr</span> <span class="v">D</span>         <span class="c">' Numery DFS</span>
<span class="i">Dim</span> <span class="i">Shared</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">L</span>         <span class="c">' Lista mostów</span>

<span class="c">' Funkcja rekurencyjna wyszukuj±ca mosty</span>
<span class="c">' v  - numer bie¿±cego wierzcho³ka</span>
<span class="c">' vf - ojciec bie¿±cego wierzcho³ka na drzewie rozpinaj±cym</span>
<span class="c">' Reszta parametrów to zmienne globalne</span>
<span class="c">'---------------------------------------</span>
<span class="i">Function</span> <span class="v">DFSb</span>(<span class="i">Byval</span> <span class="v">v</span> <span class="i">As</span> <span class="i">Integer</span>, <span class="i">Byval</span> <span class="v">vf</span> <span class="i">As</span> <span class="i">Integer</span>) <span class="i">As</span> <span class="i">Integer</span>

  <span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">Low</span>,<span class="v">temp</span>,<span class="v">u</span>
  <span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>

  <span class="c">' Numerujemy wierzcho³ek, ustalamy wstêpn± warto¶æ Low oraz zwiêkszamy numeracjê</span>

  <span class="v">D</span>[<span class="v">v</span>] = <span class="v">cv</span>: <span class="v">Low</span> = <span class="v">cv</span>: <span class="v">cv</span> += <span class="n">1</span>

  <span class="v">p</span> = <span class="v">graf</span>[<span class="v">v</span>]
  <span class="i">While</span> <span class="v">p</span>                     <span class="c">' Przegl±damy listê s±siadów</span>
    <span class="v">u</span> = <span class="v">p</span>-&gt;<span class="v">v</span>                  <span class="c">' u - numer wierzcho³ka s±siada</span>
    <span class="i">If</span> <span class="v">u</span> &lt;&gt; <span class="v">vf</span> <span class="i">Then</span>           <span class="c">' u nie mo¿e byæ ojcem v</span>
      <span class="i">If</span> <span class="v">D</span>[<span class="v">u</span>] = <span class="n">0</span> <span class="i">Then</span>        <span class="c">' Je¶li s±siad u nie by³ odwiedzany, to</span>
        <span class="v">temp</span> = <span class="v">DFSb</span>(<span class="v">u</span>,<span class="v">v</span>)      <span class="c">' rekurencyjnie odwiedzamy go</span>
        <span class="i">If</span> <span class="v">temp</span> &lt; <span class="v">Low</span> <span class="i">Then</span> <span class="v">Low</span> = <span class="v">temp</span>
      <span class="i">Else</span>
        <span class="i">If</span> <span class="v">D</span>[<span class="v">u</span>] &lt; <span class="v">Low</span> <span class="i">Then</span> <span class="v">Low</span> = <span class="v">D</span>[<span class="v">u</span>]
      <span class="i">End</span> <span class="i">If</span>
    <span class="i">End</span> <span class="i">If</span> 
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
  <span class="i">Wend</span>

  <span class="c">' Wszyscy s±siedzi zostali odwiedzeni. Teraz robimy test na most</span>

  <span class="i">If</span> (<span class="v">vf</span> &gt; -<span class="n">1</span>) <span class="i">Andalso</span> (<span class="v">Low</span> = <span class="v">D</span>[<span class="v">v</span>]) <span class="i">Then</span>
    <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>          <span class="c">' Mamy most. Dodajemy go do listy L</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
    <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
    <span class="v">L</span> = <span class="v">p</span>
    <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>
    <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">vf</span>
    <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">L</span>
    <span class="v">L</span> = <span class="v">p</span>
  <span class="i">End</span> <span class="i">If</span>

  <span class="i">Return</span> <span class="v">Low</span>                 <span class="c">' Wynik</span>
<span class="i">End</span> <span class="i">Function</span>

<span class="c">' **********************</span>
<span class="c">' *** Program g³ówny ***</span>
<span class="c">' **********************</span>

<span class="i">Dim</span> <span class="i">As</span> <span class="i">Integer</span> <span class="v">i</span>,<span class="v">u</span>,<span class="v">v</span>         <span class="c">' Numery wierzcho³ków</span>
<span class="i">Dim</span> <span class="i">As</span> <span class="v">slistEl</span> <span class="i">Ptr</span> <span class="v">p</span>,<span class="v">r</span>

<span class="i">Open</span> <span class="i">Cons</span> <span class="i">For</span> <span class="i">Input</span> <span class="i">As</span> #<span class="n">1</span>

<span class="i">Input</span> #<span class="n">1</span>,<span class="v">n</span>,<span class="v">m</span>                 <span class="c">' Odczytujemy liczbê wierzcho³ków i krawêdzi</span>

<span class="v">graf</span> = <span class="i">New</span> <span class="v">slistEl</span> <span class="i">Ptr</span> [<span class="v">n</span>]   <span class="c">' Tworzymy zmienne dynamiczne</span>
<span class="v">D</span>    = <span class="i">New</span> <span class="i">Integer</span> [<span class="v">n</span>]
<span class="v">L</span>    = <span class="n">0</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">graf</span>[<span class="v">i</span>] = <span class="n">0</span>
  <span class="v">D</span>[<span class="v">i</span>]    = <span class="n">0</span>
<span class="i">Next</span>

<span class="c">' Odczytujemy kolejne definicje krawêdzi</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">m</span> - <span class="n">1</span>
  <span class="i">Input</span> #<span class="n">1</span>,<span class="v">v</span>,<span class="v">u</span>               <span class="c">' Wierzcho³ki tworz±ce krawêd¼</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' Tworzymy nowy element</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">u</span>                   <span class="c">' Numerujemy go jako u</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">v</span>]          <span class="c">' Dodajemy go na pocz±tek listy graf[v]</span>
  <span class="v">graf</span>[<span class="v">v</span>] = <span class="v">p</span>
  <span class="v">p</span> = <span class="i">New</span> <span class="v">slistEl</span>            <span class="c">' To samo dla krawêdzi w drug± stronê</span>
  <span class="v">p</span>-&gt;<span class="v">v</span> = <span class="v">v</span>
  <span class="v">p</span>-&gt;<span class="i">Next</span> = <span class="v">graf</span>[<span class="v">u</span>]
  <span class="v">graf</span>[<span class="v">u</span>] = <span class="v">p</span>
<span class="i">Next</span>

<span class="i">Close</span> #<span class="n">1</span>

<span class="c">' Szukamy mostów</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="i">If</span> <span class="v">D</span>[<span class="v">i</span>] = <span class="n">0</span> <span class="i">Then</span>          <span class="c">' Szukamy nieodwiedzonego wierzcho³ka</span>
    <span class="v">cv</span>   =  <span class="n">1</span>               <span class="c">' Pocz±tek numeracji DFS</span>
    <span class="v">DFSb</span>(<span class="v">i</span>,-<span class="n">1</span>)              <span class="c">' Szukamy mostów</span>
  <span class="i">End</span> <span class="i">If</span>
<span class="i">Next</span>

<span class="i">Print</span> 

<span class="c">' Wypisujemy znalezione mosty, jednocze¶nie usuwaj±c listê L</span>

<span class="v">v</span> = <span class="n">0</span>

<span class="i">While</span> <span class="v">L</span>
  <span class="i">Print</span> <span class="v">L</span>-&gt;<span class="v">v</span>;
  <span class="v">v</span> = (<span class="v">v</span> + <span class="n">1</span>) <span class="i">Mod</span> <span class="n">2</span>
  <span class="i">If</span> <span class="v">v</span> = <span class="n">0</span> <span class="i">Then</span> <span class="i">Print</span>
  <span class="v">p</span> = <span class="v">L</span>
  <span class="v">L</span> = <span class="v">L</span>-&gt;<span class="i">Next</span>
  <span class="i">Delete</span> [] <span class="v">p</span>
<span class="i">Wend</span>

<span class="c">' Usuwamy dynamiczne struktury danych</span>

<span class="i">For</span> <span class="v">i</span> = <span class="n">0</span> <span class="i">To</span> <span class="v">n</span> - <span class="n">1</span>
  <span class="v">p</span> = <span class="v">graf</span>[<span class="v">i</span>]
  <span class="i">While</span> <span class="v">p</span>
    <span class="v">r</span> = <span class="v">p</span>
    <span class="v">p</span> = <span class="v">p</span>-&gt;<span class="i">Next</span>
    <span class="i">Delete</span> <span class="v">r</span>
  <span class="i">Wend</span>
<span class="i">Next</span>

<span class="i">Delete</span> [] <span class="v">D</span>
<span class="i">Delete</span> [] <span class="v">graf</span>

<span class="i">End</span> </pre></pre></td>
		</tr>
		<tr>
			<td style="text-align: center" bgcolor="#F0F0F0" colspan="2"><b>Wynik</b></td>
		</tr>
		<tr>
			<td style="text-align: left" class="program">17 17<br>0 1 0 2 0 3<br>1 2 1 14<br>4 11 4 12<br>5 6 5 9<br>6 7 6 8<br>10 15<br>11 15<br>12 15<br>13 14 13 16<br>14 16<br>
			<br>5 6<br>6 7<br>6 8<br>5 9<br>15 10<br>1 14<br>0 3</td>
			<td style="text-align: center">
			<img src="./Algorytmy i Struktury Danych - Mosty w grafie_files/0130a_01.gif" width="382" height="354"></td>
		</tr>
	</tbody></table>
	</div>
	</div>
<p>&nbsp;</p></div>
<div class="bl1">
  
<p>&nbsp;</p>
<hr color="#C0C0C0" size="1">
<div align="left">
  <table style="float: right; BORDER-COLLAPSE: collapse; padding-left:8px; padding-right:8px; padding-top:1px; padding-bottom:1px; cellPadding=" 4"="" border="0">
    <tbody><tr>
      <td><img src="./Algorytmy i Struktury Danych - Mosty w grafie_files/i-lo_budynek.jpg"></td><td valign="top"><p align="center" style="text-align: center">&nbsp;&nbsp;&nbsp;I Liceum Ogólnokszta³c±ce&nbsp;&nbsp;&nbsp;<br><span class="small">im. Kazimierza Brodziñskiego<br> w Tarnowie</span><br><span class="small">&#169;2018 mgr Jerzy Wa³aszek</span></p></td>
    </tr>
  </tbody></table>
</div>
<span class="small">Dokument ten rozpowszechniany jest zgodnie z zasadami licencji<br>
<b>GNU Free Documentation License</b>.</span><p>Pytania proszê przesy³aæ na adres email: <a href="mailto:i-lo@eduinf.waw.pl">i-lo@eduinf.waw.pl</a>
</p>
<p><span class="small">W artyku³ach serwisu s± u¿ywane cookies. Je¶li nie chcesz ich otrzymywaæ,<br>
zablokuj je w swojej przegl±darce.<br>
<a target="_blank" href="https://policies.google.com/technologies/partner-sites?hl=pl">
Informacje dodatkowe</a></span></p>

</div>

<script type="text/javascript">pcba()</script>

<ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none;"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:NaNpx;margin:0;padding:0;position:relative;visibility:visible;width:NaNpx;background-color:transparent;"><iframe frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:NaNpx;height:NaNpx;" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/saved_resource(1).html"></iframe></ins></ins></ins><iframe id="google_osd_static_frame_3922246429973" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./Algorytmy i Struktury Danych - Mosty w grafie_files/saved_resource(2).html"></iframe></body></html>